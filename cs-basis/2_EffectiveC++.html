<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EffectiveC++ | FeoBay的个人博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="https://feobay.oss-cn-shanghai.aliyuncs.com/img/terminal.svg">
    <meta name="description" content="Just for fun">
    
    <link rel="preload" href="/assets/css/0.styles.6d920bc0.css" as="style"><link rel="preload" href="/assets/js/app.72c8bf2a.js" as="script"><link rel="preload" href="/assets/js/2.2702b4bf.js" as="script"><link rel="preload" href="/assets/js/14.9fa2841e.js" as="script"><link rel="prefetch" href="/assets/js/10.a94df392.js"><link rel="prefetch" href="/assets/js/11.632e5645.js"><link rel="prefetch" href="/assets/js/12.55b415ad.js"><link rel="prefetch" href="/assets/js/13.b6a9667b.js"><link rel="prefetch" href="/assets/js/15.db6a460d.js"><link rel="prefetch" href="/assets/js/16.051721e3.js"><link rel="prefetch" href="/assets/js/17.1a82dfdf.js"><link rel="prefetch" href="/assets/js/18.b3fd6f3e.js"><link rel="prefetch" href="/assets/js/19.013ce65f.js"><link rel="prefetch" href="/assets/js/20.c1c40422.js"><link rel="prefetch" href="/assets/js/21.a2cce3e9.js"><link rel="prefetch" href="/assets/js/3.3c9c7e39.js"><link rel="prefetch" href="/assets/js/4.d25869ab.js"><link rel="prefetch" href="/assets/js/5.1840f9a3.js"><link rel="prefetch" href="/assets/js/6.03bfa775.js"><link rel="prefetch" href="/assets/js/7.368f46d5.js"><link rel="prefetch" href="/assets/js/8.e438b600.js"><link rel="prefetch" href="/assets/js/9.39ebbd5e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6d920bc0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/terminal.svg" alt="FeoBay的个人博客" class="logo"> <span class="site-name can-hide">FeoBay的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/cs-basis/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法刷题
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  随记
</a></div><div class="nav-item"><a href="https://github.com/feobay" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/cs-basis/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法刷题
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  随记
</a></div><div class="nav-item"><a href="https://github.com/feobay" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/cs-basis/" aria-current="page" class="sidebar-link">计算机基础</a></li><li><a href="/cs-basis/1_C++.html" class="sidebar-link">C++</a></li><li><a href="/cs-basis/2_EffectiveC++.html" aria-current="page" class="active sidebar-link">EffectiveC++</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款01-视c-为一个语言联邦" class="sidebar-link">条款01：视C++为一个语言联邦</a></li><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款02-尽量以const-enum-inline替换-define" class="sidebar-link">条款02：尽量以const，enum，inline替换#define</a></li><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款03-尽可能使用const" class="sidebar-link">条款03：尽可能使用const</a></li><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款04-确定对象被使用前已先被初始化" class="sidebar-link">条款04：确定对象被使用前已先被初始化</a></li><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款05-了解c-默默编写并调用哪些函数" class="sidebar-link">条款05：了解C++默默编写并调用哪些函数</a></li><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款06-若不想使用编译器自动生成的函数-就该明确拒绝" class="sidebar-link">条款06：若不想使用编译器自动生成的函数，就该明确拒绝</a></li><li class="sidebar-sub-header"><a href="/cs-basis/2_EffectiveC++.html#条款07-为多态基类声明virtual析构函数" class="sidebar-link">条款07：为多态基类声明virtual析构函数</a></li></ul></li><li><a href="/cs-basis/3_STL源码剖析.html" class="sidebar-link">STL源码剖析（侯捷）</a></li><li><a href="/cs-basis/4_ComputerNetwork.html" class="sidebar-link">计算机网络</a></li><li><a href="/cs-basis/5_操作系统.html" class="sidebar-link">操作系统</a></li><li><a href="/cs-basis/6_计算机体系结构.html" class="sidebar-link">计算机体系结构</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="effectivec"><a href="#effectivec" class="header-anchor">#</a> EffectiveC++</h1> <h2 id="条款01-视c-为一个语言联邦"><a href="#条款01-视c-为一个语言联邦" class="header-anchor">#</a> 条款01：视C++为一个语言联邦</h2> <p>C++包含四大部分</p> <p><strong>C</strong>， <strong>Objected-Oriented C++</strong>， <strong>Template C++</strong>， <strong>STL</strong></p> <h2 id="条款02-尽量以const-enum-inline替换-define"><a href="#条款02-尽量以const-enum-inline替换-define" class="header-anchor">#</a> 条款02：尽量以const，enum，inline替换#define</h2> <p>①编译器看不见define的常量名称，如 <code>#define pi 3.14</code> 在预处理后展开为3.14，编译器无法识别，这样debug时编译器报错无法追溯到具体的变量</p> <blockquote><p>C++11中用 <code>nullptr</code> (nullptr_t 类型的右值常量，专用于初始化空指针)替代 <code>NULL</code>（宏定义）</p> <ul><li><p>nullptr可以被隐式转换为任意类型的指针，但不能被隐式转换为整型；这与 NULL 不同</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span> a1 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span> a2 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span> a3 <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
            
<span class="token keyword">void</span> <span class="token function">isnull</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;void*c&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">isnull</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;int n&quot;</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">isnull</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 结果为int n</span>
<span class="token function">isnull</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 结果为void*c</span>
</code></pre></div><p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p></li></ul></blockquote> <p>②const，enum可以被封装，且enum与define类似不能被取地址</p> <p>③宏定义的函数会出一些问题，例如一下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">CALL_WITH_MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token comment">// 宏定义单纯是用匹配的位置直接进行字符串替换</span>
<span class="token comment">// 也就是说 CALL_WITH_(++a, b) 等价于</span>
<span class="token comment">// f((++a) &gt; (b) ? (++a) : (b)) , 结果是true的话a将被累加两次</span>
<span class="token comment">// 由于C/C++程序编译顺序为 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</span>
<span class="token comment">// 所以在++a(或其它表达式被计算之前)，宏定义就已经展开</span>

<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//为了避免这种错误，使用template inline可以获得同等高的效率</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">callWithMax</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//使用常量引用防止新的内存消耗且禁止在函数内部修改值</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">CALL_WITH_MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// a累加2次，第一次累加后a为6 &gt; b(0), 所以返回?后的a,此时再次累加一次得到a=7</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token function">CALL_WITH_MAX</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// a累加1次，第一次累加后a=8，a &lt; b(10), 所以?后返回b不再为a进行累加，</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 最后a为8</span>
    <span class="token function">callWithMax</span><span class="token punctuation">(</span><span class="token operator">++</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用 inline替换#define可以很好解决</p> <p>小结：</p> <ul><li>对于单纯常量，最好以const对象或enum 替换#define</li> <li>对于形似函数的宏（macros），最好改用inline函数替换#define</li></ul> <h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="header-anchor">#</a> 条款03：尽可能使用const</h2> <p>const 在 <code>*</code> 左边表示指向的对象是常量; const在<code>*</code>右边表示指针本身是常量，指向地址不变。</p> <blockquote><p>注意，<code>*</code> 肯定在类型后面才是正确的语法</p></blockquote> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> Widget<span class="token operator">*</span> pw<span class="token punctuation">;</span>
Widget <span class="token keyword">const</span> <span class="token operator">*</span> pw<span class="token punctuation">;</span> <span class="token comment">// 两种都是对象是常量</span>
</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token keyword">const</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">//指向的对象是常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token keyword">const</span> p3 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">//指针是常量</span>
</code></pre></div><p>对于迭代器，<code>const</code> 关键字直接作用于 <code>iterator</code> 本身，会得到一个<strong>指向无法改变</strong>的指针；（iterator作用类似于T*, const iterator 类似于 T * const)</p> <blockquote><p>const (type)::iterator it; ++it; // 错误，it指向无法改变</p></blockquote> <p>想要<strong>内容无法改变的迭代器</strong>，则可以 直接用 <code>::const_iterator</code> (const_iterator 作用类似于 const T *)</p> <blockquote><p>(type)::const_itarotor cIt; ++cIt; // 正确，指向可以改变 *cIt = 2; // 错误，cIt指向对象的内容无法被更改</p></blockquote> <p><strong><code>const</code> 可以用来声明 函数返回值、各参数、函数自身（如果是成员函数，类中的长函数，在函数名后声明const）</strong></p> <p><font color="blue"><strong>为什么要将返回值声明为const？</strong></font></p> <p>是为了防止表达式的结果被更改，比如进行 operator* 运算符重载时返回常量，让其成为右值。 避免以下错误：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">=</span> c<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// 将 operator* 的返回值定义为const，这种无意识的错误就可以避免</span>
</code></pre></div><p>对于 <code>operator[]</code> 如果返回值类型为 char 的 引用，那么返回值可以修改，但如果单纯返回的是一个内置类型如char，由于其为字面值（右值）而非变量，所以无法修改。</p> <p><font color="blue"><strong>const 成员函数的作用？</strong></font></p> <ul><li>使得class接口易于被理解，易于分辨哪些函数可以改动对象内容而哪些不可以</li> <li>用于实现 <em><strong>pass by reference-to-const</strong></em> ，<code>void func(const T&amp; a) const {}</code></li></ul> <p><font color="blue"><strong>成员函数可以通过其常量性不同来重载。</strong></font></p> <p><font color="blue"><strong>const成员函数有两种哲学：</strong></font></p> <ul><li><p><font color="blue"><strong>bitwise constness</strong></font>：不改变对象中的任何一个bit</p> <blockquote><p>有个问题，根据该原则，对象的所属成员指针指向不能改变，但指针指向的对象却不属于初始对象，所以其内容可以改变。</p> <p>PS：mutable 关键字有助于释放 non-static 成员变量的 bitwise-constness</p></blockquote></li> <li><p><font color="blue"><strong>logical constness</strong></font>：const成员函数可以修改它所处理的对象内的某些bits</p> <blockquote><p>可以根据所需要达成的目的，进行逻辑上的约束</p></blockquote></li></ul> <p><font color="blue"><strong>运算符重载可以做很多安全性检测。</strong></font></p> <blockquote><p>operator[] 不单是返回一个 reference 指向某字符，也执行 边界检验（bounds checking）、志记访问信息（logged access info）、数据完整性检验。</p></blockquote> <p>将这些检验同时塞进const 和 non-const operator[] 中就会引发很多问题。为了解决这个问题，我们就需要：</p> <p><font color="blue"><strong>消除重复代码，在 non-const operator[] 中调用 const operator[].</strong></font></p> <p>具体做法如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t position<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">return</span> text<span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t position<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>					<span class="token comment">// 将op[]的返回值的const移除</span>
        	<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token comment">// 为*this加上cosnt</span>
            	<span class="token punctuation">[</span>position<span class="token punctuation">]</span>							<span class="token comment">// 调用const char&amp; op[]</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>可以看到进行了两次转型：</p> <ul><li>第一次为 *this 添加 const（这使得接下来调用 operator[] 时得以调用 const 版本）</li> <li>第二次 则是从 const operator[] 的返回值中移除 const</li></ul></blockquote> <p>如果在const函数内调用non-const版本，那么可能出现风险：你曾承诺不改动的那个对象被改动了。</p> <p><strong>小结：</strong></p> <ul><li>将某些东西声明为const有助于编译器侦测出错误用法</li> <li>编译器强制实施 bitwise constness，但我们编写程序时应当使用“概念上的常量性”（conceptual constness)</li> <li>当 const 和 non-const 版本成员函数有着实质等价的实现时，<strong>在 non-const 版本中调用 const 版本可避免代码重复</strong></li></ul> <h2 id="条款04-确定对象被使用前已先被初始化"><a href="#条款04-确定对象被使用前已先被初始化" class="header-anchor">#</a> 条款04：确定对象被使用前已先被初始化</h2> <p><strong>做法：</strong></p> <ul><li><p>手动初始化</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>								<span class="token comment">// 对 int 进行手工初始化</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> text <span class="token operator">=</span> <span class="token string">&quot;A C-style string&quot;</span><span class="token punctuation">;</span>  <span class="token comment">// 对指针进行手工初始化</span>

<span class="token keyword">double</span> d<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> d<span class="token punctuation">;</span> 							<span class="token comment">// 通过 input stream 的方式完成初始化</span>
</code></pre></div></li> <li><p>内置类型以外的通过 <strong>构造函数（constructors）初始化</strong></p> <blockquote><p>规则就是：确保每一个构造函数都将对象的每一个成员初始化</p> <p>要注意的就是不要混淆 <strong>赋值</strong>（在函数体内使用 ‘=’ 叫做赋值） 和 <strong>初始化</strong>（通过参数列表初始化）</p> <p>C++定义：对象成员变量的初始化发生于进入构造函数体内之前</p> <p>所以也可以在对象成员生命处直接初始化，然后默认构造函数直接声明外 name() = default;（注意：static成员应该在类内声明类外初始化）</p></blockquote></li></ul> <p>基于赋值的版本首先调用 <em><strong>default</strong></em> 构造函数为成员变量赋初值，然后为他们设置新值，这样 第一次赋初值就浪费了。所以通过成员初始值列表来初始化避免该问题。</p> <p>也就是说：构造函数赋值 = 先 default构造 + 再 调用 copy assignment 操作符</p> <p>如果只想要使用 <em><strong>default</strong></em> 构造一个成员变量，也可以通过无参的成员初值列表来实现：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token class-name">ABEntry</span><span class="token double-colon punctuation">::</span><span class="token function">ABEntry</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	  <span class="token function">theAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	  <span class="token function">thePhones</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 			<span class="token comment">// 因为编译器会为用户自定义类型自动调用默认构造函数，所以前三个会调用它们的 default 构造函数</span>
      <span class="token function">numTimesConsulted</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token punctuation">}</span>
</code></pre></div><p><font color="red"><strong>记住要在初值列表中列出所有成员变量。</strong></font></p> <blockquote><p>如果遗漏了就会导致有些成员没有初值，进而引发不明确行为。</p></blockquote> <p><strong>额外注意：</strong></p> <ul><li><p>对于有些内置类型也需要使用初值列表</p> <p><font color="blue"><strong>成员变量为 const 或 reference，就一定需要处初值列表，不能只用赋值</strong></font></p> <p>所以最好的做法就是所有时候都<strong>只用 初始化列表</strong></p></li> <li><p>合理使用赋值替换初始化</p> <blockquote><p>许多 classes 拥有多个构造函数，每个构造函数有自己的成员初值列表。如果 这种 classes 里边存在许多成员变量和/或 base classes，多份成员初值列表会导致许多重复初始化，这时候可以合理用一些赋值来替换初始化某些变量，同时赋值操作就一起封装在某个private成员函数中，提供给构造函数使用。</p> <p>这种做法在 <font color="blue"><strong>从文件或数据库中读入数据来给成员变量赋初值时</strong></font> 很有用</p></blockquote></li> <li><p>初始化最好按照声明顺序初始化</p></li> <li><p>还需要注意 <code>non-local static</code> 对象 的初始化顺序</p> <ul><li><p>static 对象寿命从被构造出来直到程序结束为止</p></li> <li><p>函数内的 static对象为 local static，它们是函数内的局部变量</p></li> <li><p>其它static（global对象、namespace作用域内的对象、classes内的、file作用域内被声明的static）都是 non-local static</p></li> <li><p>程序结束时，static对象会被自动销毁，它们的析构函数会在 main() 结束时被自动调用</p></li> <li><p><font color="blue"><strong>问题：某编译单元内的某个non-local static 对象的初始化动作使用了另一个编译单元内的某个 non-local static 对象，它所使用的对象可能并未初始化，因为C++并未定义不同编译单元内static对象的初始化顺序。</strong></font></p> <blockquote><p>编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上它是单一源码文件加上其所含入的头文件。</p></blockquote> <p>消除该问题需要做的是：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static）。这些函数返回一个 reference 指向它所含的对象。<code>T&amp; getX() { static T x; return x;}</code> 然后用户调用这些函数而不直接指涉这些对象。换句话说，non-static 对象被 local static 对象替换了。这是 ***Singleton***模式（单例模式）的经典实现。</p> <p>这个手法的基础：C++保证，函数内的local static 对象会在 “该函数被调用期间” ”第一次遇上该对象的定义式“ 时被初始化。所以用 ”函数调用“（返回一个 reference to local static) 替换 ”直接访问non-local static 对象“，可以保证所获得的reference将指向一个被初始化的对象。并且 <strong>如果从未调用那个non-static 对象的<code>getX()</code>  函数，那么就一定不会引发构造和析构成本，这比真正的 non-local static 对象更有优势。</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 来自你写的服务端程序：</span>
<span class="token keyword">class</span> <span class="token class-name">FileSystem</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">// 下面时来自客户端的程序</span>
<span class="token comment">// 省去了 extern tfs</span>
FileSystem<span class="token operator">&amp;</span> <span class="token function">tfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>				<span class="token comment">// 用这个函数来替换tfs对象</span>
    <span class="token keyword">static</span> FileSystem fs<span class="token punctuation">;</span>		<span class="token comment">// 定义并初始化一个local static对象（这里的fs已经在服务端程序初始化）</span>
    <span class="token keyword">return</span> fs<span class="token punctuation">;</span>					<span class="token comment">// 返回一个 reference 指向上述对象</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Directory</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">Directory</span><span class="token double-colon punctuation">::</span><span class="token function">Directory</span><span class="token punctuation">(</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    std<span class="token double-colon punctuation">::</span>size_t disks <span class="token operator">=</span> <span class="token function">tfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">numDisks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 使用tfs() 来替换直接访问 tfs对象</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

Directory<span class="token operator">&amp;</span> <span class="token function">tempDir</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> Directory td<span class="token punctuation">;</span> <span class="token comment">// 定义并初始化 local static 对象</span>
    <span class="token keyword">return</span> td<span class="token punctuation">;</span>			 <span class="token comment">// 返回一个reference指向上述对象</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这种简短的函数及其适合inline</span>
</code></pre></div></li> <li><p>同时上述做法会让其在多线程函数中出现隐患</p> <p><font color="blue"><strong>在程序的的单线程启动阶段手工调用所有 reference-returning 函数，可以消除与初始化次序有关的”竞速情况”</strong></font></p></li></ul></li></ul> <p><strong>小结：</strong></p> <ul><li><strong>为内置型对象进行手工初始化，因为C++不保证初始化它们。</strong></li> <li><strong>构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。</strong></li> <li><strong>为免除”跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象</strong>。</li></ul> <h2 id="条款05-了解c-默默编写并调用哪些函数"><a href="#条款05-了解c-默默编写并调用哪些函数" class="header-anchor">#</a> 条款05：了解C++默默编写并调用哪些函数</h2> <p>如果你没有声明，C++类中默认有 <strong>默认构造函数、一个拷贝构造函数、一个拷贝赋值操作符（=）重载函数、一个析构函数</strong>，它们都是 <strong>public 且 inline 的。</strong></p> <p>并且从左到有，如果你自己手动声明了一个默认构造函数的化，那么左边的那些函数系统就不会再生成。</p> <p>比如：你自己定义了一个拷贝构造，那么系统不再给你提供默认构造。</p> <p>例子：</p> <blockquote><p>对于一个空类 empty</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">empty</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>其等价于</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">empty</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>								<span class="token comment">// default构造函数</span>
    <span class="token function">Empty</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>				<span class="token comment">// copy构造函数</span>
    <span class="token operator">~</span><span class="token function">Empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>							<span class="token comment">// 析构函数</span>
    											<span class="token comment">// virtual 函数后面再说</span>
    Empty<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Empty<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>	<span class="token comment">// copy assignment构造函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></blockquote> <p><font color="blue"><strong>编译器产出的析构函数时non-virtual的，virtual属性需要手动声明，除非它的base class的析构函数是个virtual的</strong></font></p> <p><font color="blue"><strong>如果你编写了一个有参构造函数，那么编译器不再提供默认构造函数；并且，对于默认拷贝构造函数而言，对应的参数一定需要对应才行</strong></font></p> <h2 id="条款06-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#条款06-若不想使用编译器自动生成的函数-就该明确拒绝" class="header-anchor">#</a> 条款06：若不想使用编译器自动生成的函数，就该明确拒绝</h2> <p>一般来说不想要某个函数自己不声明就够了，但是对于默认生成的则需要手动控制。</p> <p><strong>下面是方法：</strong></p> <ol><li><p><strong>将编译器默认生成的拷贝函数声明为private并且不定义</strong>。但这个做法不完全安全，因为成员函数和友元friend函数都可以调用private，但不定义就可以做到防止被人调用（此时会返回链接错误）。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Uncopyable</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">friend</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Uncopyable</span><span class="token punctuation">(</span><span class="token keyword">const</span> Uncopyable <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Newuc</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Uncopyable</span></span> <span class="token punctuation">{</span>

<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Uncopyable c1<span class="token punctuation">;</span>
    Uncopyable <span class="token function">c2</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Newuc nc1;</span>
    <span class="token comment">// Newuc nc2(nc1);</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用 <code>func()</code> 发现报错 <code>collect2.exe: error: ld returned 1 exit status</code></p> <p><strong>而有了一个这种不可被拷贝的类后，子类只需要私有继承这个不可被拷贝类即可使其自身也不可被拷贝</strong>，因为父类的拷贝构造被定义为私有的，所以子类不能调用父类的拷贝构造函数，所以子类中的拷贝构造被删除。</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20230331201359958.png" alt="image-20230331201359958"></p></li> <li><p><strong>使用C++11提供的delete关键词新用法</strong>。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">MyObj</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">MyObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 阻止编译器合成构造函数，会导致类无法实例化</span>
  MyObj<span class="token operator">&amp;</span> <span class="token function">MyObj</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyObj <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout</span>
  MyObj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyObj <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ol> <p><strong>小结</strong>：为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为 <code>private</code> 并且不予实现。使用像Uncopyable这样的base class也是一种做法。</p> <h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="header-anchor">#</a> 条款07：为多态基类声明virtual析构函数</h2> <p>virtual函数一般用于多态，使用父类指针指向子类对象时，通过父类指针调用函数，此时调用的是子类函数，这就是多态。</p> <p>实现原理：使用virtual后会在子类对象中添加一个函数指针，函数指针指向一个虚函数表，虚函数表中存放了virtual函数的函数地址，如果子类重写了父类中的虚函数，那么就由子类函数的地址覆盖父类函数地址。</p> <ul><li><p>当基类的指针指向子类的对象，而基类的析构函数不是虚析构，那么此时 delete父类指针时就不会执行子类析构，导致内存泄漏</p></li> <li><p>如果要继承std::string，也不行，因为std::string有个非虚析构函数</p></li> <li><p>有时候可以考虑声明一个纯析构函数</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">ClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 使该类成为抽象类，不能实例化</span>
</code></pre></div></li> <li><p>析构函数的调用规则是，先子类后父类</p></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cs-basis/1_C++.html" class="prev">
        C++
      </a></span> <span class="next"><a href="/cs-basis/3_STL源码剖析.html">
        STL源码剖析（侯捷）
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.72c8bf2a.js" defer></script><script src="/assets/js/2.2702b4bf.js" defer></script><script src="/assets/js/14.9fa2841e.js" defer></script>
  </body>
</html>
