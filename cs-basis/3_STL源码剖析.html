<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>STL源码剖析（侯捷） | FeoBay的个人博客</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="https://feobay.oss-cn-shanghai.aliyuncs.com/img/terminal.svg">
    <meta name="description" content="Just for fun">
    
    <link rel="preload" href="/assets/css/0.styles.6d920bc0.css" as="style"><link rel="preload" href="/assets/js/app.72c8bf2a.js" as="script"><link rel="preload" href="/assets/js/2.2702b4bf.js" as="script"><link rel="preload" href="/assets/js/15.db6a460d.js" as="script"><link rel="prefetch" href="/assets/js/10.a94df392.js"><link rel="prefetch" href="/assets/js/11.632e5645.js"><link rel="prefetch" href="/assets/js/12.55b415ad.js"><link rel="prefetch" href="/assets/js/13.b6a9667b.js"><link rel="prefetch" href="/assets/js/14.9fa2841e.js"><link rel="prefetch" href="/assets/js/16.051721e3.js"><link rel="prefetch" href="/assets/js/17.1a82dfdf.js"><link rel="prefetch" href="/assets/js/18.b3fd6f3e.js"><link rel="prefetch" href="/assets/js/19.013ce65f.js"><link rel="prefetch" href="/assets/js/20.c1c40422.js"><link rel="prefetch" href="/assets/js/21.a2cce3e9.js"><link rel="prefetch" href="/assets/js/3.3c9c7e39.js"><link rel="prefetch" href="/assets/js/4.d25869ab.js"><link rel="prefetch" href="/assets/js/5.1840f9a3.js"><link rel="prefetch" href="/assets/js/6.03bfa775.js"><link rel="prefetch" href="/assets/js/7.368f46d5.js"><link rel="prefetch" href="/assets/js/8.e438b600.js"><link rel="prefetch" href="/assets/js/9.39ebbd5e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.6d920bc0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/terminal.svg" alt="FeoBay的个人博客" class="logo"> <span class="site-name can-hide">FeoBay的个人博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/cs-basis/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法刷题
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  随记
</a></div><div class="nav-item"><a href="https://github.com/feobay" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/cs-basis/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  算法刷题
</a></div><div class="nav-item"><a href="/notes/" class="nav-link">
  随记
</a></div><div class="nav-item"><a href="https://github.com/feobay" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/cs-basis/" aria-current="page" class="sidebar-link">计算机基础</a></li><li><a href="/cs-basis/1_C++.html" class="sidebar-link">C++</a></li><li><a href="/cs-basis/2_EffectiveC++.html" class="sidebar-link">EffectiveC++</a></li><li><a href="/cs-basis/3_STL源码剖析.html" class="active sidebar-link">STL源码剖析（侯捷）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_1-认识headers、版本及学习c-重要资源" class="sidebar-link">1.认识headers、版本及学习C++重要资源</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#headers" class="sidebar-link">headers</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_2-c-stl体系结构基础" class="sidebar-link">2.C++STL体系结构基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#六大部件-components" class="sidebar-link">六大部件（Components）：</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#一些容器中相关的关键字" class="sidebar-link">一些容器中相关的关键字</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_3-容器之分类与各种测试" class="sidebar-link">3. 容器之分类与各种测试</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#容器在内存中的结构概览" class="sidebar-link">容器在内存中的结构概览</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#各个容器的方法及效率总结" class="sidebar-link">各个容器的方法及效率总结</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#array" class="sidebar-link" style="padding-left:3rem;">array</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#vector" class="sidebar-link" style="padding-left:3rem;">vector</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#list" class="sidebar-link" style="padding-left:3rem;">list</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#deque" class="sidebar-link" style="padding-left:3rem;">deque</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#stack" class="sidebar-link" style="padding-left:3rem;">stack</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#queue" class="sidebar-link" style="padding-left:3rem;">queue</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#set-multiset" class="sidebar-link" style="padding-left:3rem;">set/multiset</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#map-multimap" class="sidebar-link" style="padding-left:3rem;">map/multimap</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#unordered-set" class="sidebar-link" style="padding-left:3rem;">unordered_set</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#unordered-map" class="sidebar-link" style="padding-left:3rem;">unordered_map</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#分配器测试" class="sidebar-link">分配器测试</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#allocator" class="sidebar-link" style="padding-left:3rem;">allocator</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_4-c-stl体系结构" class="sidebar-link">4 C++STL体系结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_4-1-c-源码文件布局" class="sidebar-link">4.1 C++源码文件布局</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_4-2-oop-面向对象编程-vs-gp-泛型编程" class="sidebar-link">4.2 OOP（面向对象编程）vs. GP（泛型编程）</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_4-3-阅读c-stl的技术基础" class="sidebar-link">4.3 阅读C++STL的技术基础</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_5-c-stl源码剖析" class="sidebar-link">5 C++STL源码剖析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_5-1-分配器allocators" class="sidebar-link">5.1 分配器allocators</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_5-2-容器之间的实现关系与分类" class="sidebar-link">5.2 容器之间的实现关系与分类</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_5-3-容器list" class="sidebar-link">5.3 容器list</a></li><li class="sidebar-sub-header"><a href="/cs-basis/3_STL源码剖析.html#_5-4-迭代器的设计原则和iterator-traits的作用与设计" class="sidebar-link">5.4 迭代器的设计原则和Iterator Traits的作用与设计</a></li></ul></li></ul></li><li><a href="/cs-basis/4_ComputerNetwork.html" class="sidebar-link">计算机网络</a></li><li><a href="/cs-basis/5_操作系统.html" class="sidebar-link">操作系统</a></li><li><a href="/cs-basis/6_计算机体系结构.html" class="sidebar-link">计算机体系结构</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="stl源码剖析-侯捷"><a href="#stl源码剖析-侯捷" class="header-anchor">#</a> STL源码剖析（侯捷）</h1> <p>本文件为个人学习C++STL的笔记（仅限C++11）</p> <h2 id="_1-认识headers、版本及学习c-重要资源"><a href="#_1-认识headers、版本及学习c-重要资源" class="header-anchor">#</a> 1.认识headers、版本及学习C++重要资源</h2> <p>STL = Standard Template Library (标准模板库)</p> <p>C++参考网站推荐 https://zh.cppreference.com/</p> <p>学习C++STL源码<strong>所需要知识</strong></p> <ul><li>C++基本语法（正确使用模板，templates)</li></ul> <p><strong>学习目标</strong></p> <ul><li>lv0: 了解C++标准库的用法及复杂度</li> <li>lv1：熟悉C++标准库实现结构，做到胸中有丘壑</li> <li>lv2：良好使用C++标准库</li> <li>lv3：扩充C++标准库</li></ul> <h3 id="headers"><a href="#headers" class="header-anchor">#</a> headers</h3> <ul><li><p>STL以header files的形式被引入，并且不带.h，例如 <code>#include&lt;vector&gt;</code></p></li> <li><p>新式C header files 也可以不带 .h，例如 <code>#include &lt;cstdio&gt;</code></p></li> <li><p>旧式C header files 也可以使用，例如 <code>#include &lt;stdio.h&gt;</code></p></li> <li><p>命名空间</p> <ul><li><p><code>using namespace std;</code> or <code>using std::cout;</code></p></li> <li><p>亦可自命名如下：</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 在主函数外自命名一个命名空间</span>
<span class="token keyword">namespace</span> jj01 <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> <span class="token function">strLonger</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   cout <span class="token operator">&lt;&lt;</span> jj01<span class="token double-colon punctuation">::</span><span class="token function">strLonger</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello2&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>旧式C header files 不封装于 namespace std</p></li></ul> <h2 id="_2-c-stl体系结构基础"><a href="#_2-c-stl体系结构基础" class="header-anchor">#</a> 2.C++STL体系结构基础</h2> <p>Standard Template Library</p> <h3 id="六大部件-components"><a href="#六大部件-components" class="header-anchor">#</a> <strong>六大部件（Components）：</strong></h3> <ul><li>容器（Containers)</li> <li>分配器（Allocators）</li> <li>算法（Algorithms）</li> <li>适配器（Adapters）</li> <li>迭代器（Iterators）</li> <li>仿函数（Functors)</li></ul> <p><strong>它们的关系图如下：</strong></p> <img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701092028919.png" alt="image-20220701092028919" style="zoom:50%;"> <p><strong>下面是一段使用了六大类型STL的程序：</strong></p> <img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701093219162.png" alt="image-20220701093219162" style="zoom:50%;"> <p>各个函数解释如下：</p> <p><strong>1. count_if</strong> : 返回在 <code>[first, last)</code> 范围内满足特定条件的元素的数目。</p> <p><strong>2. not1</strong>: <code>std::not1</code> 和 <code>std::not2</code> 是用来把符合某种特殊条件的『函数对象』转换为反义「函数对象」的函数。</p> <p>具体的：</p> <p>not1是构造一个与谓词结果相反的一元函数对象。
not2是构造一个与谓词结果相反的二元函数对象。</p> <p><strong>3. bind2nd</strong>: <code>bind1st</code>和 <code>bind2nd</code> 是将二元函数转换为一元函数，比如一个比较大小的函数是二元函数，当在某些情况下我们想要固定第一个参数（<code>bind1st</code>）或者第二个参数（<code>bind2nd</code>）时，就成了一元函数.在此处是将仿函数 <code>less&lt;int&gt;()</code> 的第二个参数绑定为40.</p> <p><strong>4. less&lt;int&gt;()</strong>: <code>less&lt;datatype&gt;(dataType x, dataType y)</code>, 其返回值为 谓词 <code>x &lt; y</code> 的 <code>bool</code> 类型结果。（<code>greater&lt;int&gt;()</code>同理），关于less对象源码和bind2nd源码，可参考博客 <a href="https://blog.csdn.net/u012936940/article/details/81192956" target="_blank" rel="noopener noreferrer">C++ bind2nd用法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>所以 <code>count_if(vi.begin(), vi.end(), not1(bind2nd(less&lt;int&gt;(), 40) ) )</code>是指：</p> <blockquote><p>返回vi容器中在区间 [vi.begin(), vi.end()) 中不小于40的元素的个数</p></blockquote> <p>运行结果：</p> <blockquote><p>4</p></blockquote> <h3 id="一些容器中相关的关键字"><a href="#一些容器中相关的关键字" class="header-anchor">#</a> 一些容器中相关的关键字</h3> <p><strong>关于iterator</strong></p> <p>我们可以将迭代器（iterator）理解为泛化指针，指针能做的，它也可以做，比如重载了 <code>*</code> 号</p> <p><strong>since C++11的for range遍历语法(range based for statement)</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>declaration <span class="token operator">:</span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    statement
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> <span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> elem <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> elem <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> elem <span class="token operator">:</span> vec<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elem <span class="token operator">*=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>关于auto</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator ite<span class="token punctuation">;</span>
ite <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在可以直接使用auto自动类型推断 ↓</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>list<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span> c<span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">auto</span> ite <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">find</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_3-容器之分类与各种测试"><a href="#_3-容器之分类与各种测试" class="header-anchor">#</a> 3. 容器之分类与各种测试</h2> <h3 id="容器在内存中的结构概览"><a href="#容器在内存中的结构概览" class="header-anchor">#</a> 容器在内存中的结构概览</h3> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701103515425.png" alt="image-20220701103515425"></p> <p>红框中为C++11标准出现</p> <p><strong>顺序容器(Sequence Containers):</strong></p> <p><strong>Array</strong> : 是封闭的数组，不可扩展（将数组包装成一个类）</p> <p><strong>Vector</strong> : 是半开放的动态数组，可以扩展，空间不够则自动x2，自动扩充由分配器来做.</p> <p><strong>Deque</strong> : 双端队列，后续解释如何实现</p> <p><strong>List</strong>  : 双向链表（双向环状链表）</p> <p><strong>Forward-List</strong> ：单向链表</p> <p><strong>关联容器(Associated Containers):</strong></p> <p><strong>Set/Multiset:</strong> 红黑树，高度平衡二叉搜索树；Set中元素不可重复，Multiset可以。</p> <p><strong>Map/Multimap:</strong> 也是红黑树，但每个节点分为key-value；同理，Map的key不可重复，Multimap的key可以重复。</p> <p><strong>无序容器（Unordered Conatiners）：</strong></p> <p><strong>Unordered Set/Multiset</strong> : 底层是用拉链法解决碰撞的哈希表实现(HashTable Separate Chaining)</p> <p><strong>Unordered Map/Multimap</strong> : 也是用拉链法。</p> <p>它们的主要功能与普通的Set/Map类似，且查找效率更高为<code>O(1)</code>；不同的是它们<strong>不可排序</strong>。</p> <h3 id="各个容器的方法及效率总结"><a href="#各个容器的方法及效率总结" class="header-anchor">#</a> 各个容器的方法及效率总结</h3> <p><code>std::find(c.begin(), c.end(), target)</code> 为顺序查找。</p> <p>std::bsearch() 为二分查找（前提是原容器需要有序）</p> <p><strong>需要注意各个容器迭代器失效的情况</strong></p> <h4 id="array"><a href="#array" class="header-anchor">#</a> <a href="https://cplusplus.com/reference/array/array/" target="_blank" rel="noopener noreferrer"><strong>array</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><code>template &lt; class T, size_t N &gt; class array;</code> T为类型，N为大小</p> <table><thead><tr><th>方法</th> <th>作用</th> <th>复杂度</th></tr></thead> <tbody><tr><td>size()</td> <td>返回元素个数</td> <td></td></tr> <tr><td>front()</td> <td>返回第一个元素</td> <td>O(1)</td></tr> <tr><td>back()</td> <td>返回最后一个元素</td> <td>O(1)</td></tr> <tr><td>data()</td> <td>返回指向作为元素存储工作的底层数组的指针</td> <td>O(1)</td></tr> <tr><td>fill(T val)</td> <td>将所有元素的值都设为val</td> <td>O(n)</td></tr></tbody></table> <h4 id="vector"><a href="#vector" class="header-anchor">#</a> <a href="https://cplusplus.com/reference/vector/vector/" target="_blank" rel="noopener noreferrer"><strong>vector</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>也可以参考 <a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener noreferrer">vector<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，需要注意指针失效的情况</p> <p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class vector; // generic template</code></p> <p>注意，如果内存重新分配，那么原来的指针将失效。</p> <table><thead><tr><th>方法</th> <th>作用</th> <th>复杂度</th></tr></thead> <tbody><tr><td>size()</td> <td>返回元素个数</td> <td>O(1)</td></tr> <tr><td>capacity()</td> <td>返回容器容量（已申请的空间）</td> <td>O(1)</td></tr> <tr><td>empty()</td> <td>返回容器是否为空（空返回true，非空返回false）</td> <td>O(1)</td></tr> <tr><td>shrink_to_fit()</td> <td>使容器空间收缩为元素所占空间大小（需要一个个遍历释放空间）</td> <td>O(n)</td></tr> <tr><td>swap(vector&amp; other)</td> <td>将内容与 <code>other</code> 的交换。不在单独的元素上调用任何移动、复制或交换操作。所有迭代器和引用保持合法。尾后迭代器被非法化。</td> <td>O(1)</td></tr> <tr><td>erase()</td> <td>删除指定元素</td> <td>O(n)</td></tr> <tr><td>insert(iterator pos, const T&amp; val)</td> <td>有重载，这里说一般用法</td> <td>O(1)</td></tr> <tr><td>push_back(T&amp; val)</td> <td>将元素添加到容器末尾</td> <td>O(1)</td></tr> <tr><td>emplace_back(T&amp; val)</td> <td>在容器末尾就地构造元素</td> <td>O(1)</td></tr></tbody></table> <h4 id="list"><a href="#list" class="header-anchor">#</a> <a href="https://zh.cppreference.com/w/cpp/container/list" target="_blank" rel="noopener noreferrer"><strong>list</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class list;</code></p> <p>底层是双向链表。</p> <table><thead><tr><th>方法</th> <th>作用</th> <th>复杂度</th></tr></thead> <tbody><tr><td>size()</td> <td>返回存放元素个数</td> <td>O(1)</td></tr> <tr><td>max_size()</td> <td>返回list能容纳的最大元素数量</td> <td>O(1)</td></tr> <tr><td>pop_front()/pop_back()</td> <td>移除首/尾元素</td> <td>O(1)</td></tr> <tr><td>push_front()/push_back()</td> <td>将元素添加到容器起始/尾部</td> <td>O(1)</td></tr> <tr><td>emplace_front()/emplace_back()</td> <td>在容器起始/末尾就地构造元素</td> <td>O(1)</td></tr> <tr><td>merge()</td> <td>合并二个已排序列表</td> <td>O(n)</td></tr> <tr><td>unique()</td> <td>删除连续的重复元素</td> <td>O(n)</td></tr> <tr><td>reverse()</td> <td>将该链表的所有元素的顺序反转。不非法化任何引用或迭代器。</td> <td>O(n)</td></tr> <tr><td><a href="https://zh.cppreference.com/w/cpp/container/list/splice" target="_blank" rel="noopener noreferrer">splice()<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td> <td>从另一个<code>list</code>中移动元素</td> <td>O(n)/O(1)</td></tr></tbody></table> <h4 id="deque"><a href="#deque" class="header-anchor">#</a> <a href="https://zh.cppreference.com/w/cpp/container/deque" target="_blank" rel="noopener noreferrer"><strong>deque</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><code>template &lt; class T, class Alloc = allocator&lt;T&gt; &gt; class deque;</code></p> <img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701164210395.png" alt="image-20220701164210395" style="zoom:67%;"> <p>deque在内存空间中实际上是分段的，只是使用时看起来时连续的。</p> <p>空间利用率高，但查找慢。</p> <h4 id="stack"><a href="#stack" class="header-anchor">#</a> <a href="https://zh.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener noreferrer"><strong>stack</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><code>template &lt;class T, class Container = deque&lt;T&gt; &gt; class stack;</code></p> <p><code>stack</code> 是用 <code>deque</code> 封装实现的，所以它属于<strong>容器适配器</strong></p> <img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701171941950.png" alt="image-20220701171941950" style="zoom:80%;"> <h4 id="queue"><a href="#queue" class="header-anchor">#</a> <a href="https://zh.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener noreferrer"><strong>queue</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span>
  <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">Container</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>deque<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">queue</span><span class="token punctuation">;</span>
</code></pre></div><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701172607482.png" alt="image-20220701172607482" style="zoom:67%;"> <h4 id="set-multiset"><a href="#set-multiset" class="header-anchor">#</a> <a href="https://cplusplus.com/reference/set/" target="_blank" rel="noopener noreferrer">set/multiset<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>关联容器的效率是</p> <p><strong>set</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>                        <span class="token comment">// set::key_type/value_type</span>
           <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span>        <span class="token comment">// set::key_compare/value_compare</span>
           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>      <span class="token comment">// set::allocator_type</span>
           <span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">set</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>multiset</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>                        <span class="token comment">// multiset::key_type/value_type</span>
           <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span>        <span class="token comment">// multiset::key_compare/value_compare</span>
           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>    <span class="token comment">// multiset::allocator_type</span>
           <span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">multiset</span><span class="token punctuation">;</span>
</code></pre></div><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701173516542.png" alt="image-20220701173516542" style="zoom:67%;"> <h4 id="map-multimap"><a href="#map-multimap" class="header-anchor">#</a> <a href="https://cplusplus.com/reference/map/" target="_blank" rel="noopener noreferrer">map/multimap<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p><strong>map</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span>                                     <span class="token comment">// map::key_type</span>
           <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>                                       <span class="token comment">// map::mapped_type</span>
           <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>                     <span class="token comment">// map::key_compare</span>
           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> Key<span class="token punctuation">,</span>T<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>    <span class="token comment">// map::allocator_type</span>
           <span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">map</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>multimap</strong></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span>                                     <span class="token comment">// multimap::key_type</span>
           <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>                                       <span class="token comment">// multimap::mapped_type</span>
           <span class="token keyword">class</span> <span class="token class-name">Compare</span> <span class="token operator">=</span> less<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>                     <span class="token comment">// multimap::key_compare</span>
           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> Key<span class="token punctuation">,</span>T<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>    <span class="token comment">// multimap::allocator_type</span>
           <span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">multimap</span><span class="token punctuation">;</span>
</code></pre></div><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701175034270.png" alt="image-20220701175034270" style="zoom:67%;"> <p>底层实现红黑树，查找效率$$O(nlog_2(n))$$</p> <h4 id="unordered-set"><a href="#unordered-set" class="header-anchor">#</a> <a href="https://cplusplus.com/reference/unordered_set/" target="_blank" rel="noopener noreferrer">unordered_set<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>底层hash表</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span>                        <span class="token comment">// unordered_set::key_type/value_type</span>
           <span class="token keyword">class</span> <span class="token class-name">Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>           <span class="token comment">// unordered_set::hasher</span>
           <span class="token keyword">class</span> <span class="token class-name">Pred</span> <span class="token operator">=</span> equal_to<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>       <span class="token comment">// unordered_set::key_equal</span>
           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span>      <span class="token comment">// unordered_set::allocator_type</span>
           <span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">unordered_set</span><span class="token punctuation">;</span>
</code></pre></div><p>测试</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701180236052.png" alt="image-20220701180236052"></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701180320868.png" alt="image-20220701180320868"></p> <h4 id="unordered-map"><a href="#unordered-map" class="header-anchor">#</a> <a href="https://cplusplus.com/reference/unordered_map/" target="_blank" rel="noopener noreferrer">unordered_map<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h4> <p>底层为hash表</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Key</span><span class="token punctuation">,</span>                                    <span class="token comment">// unordered_map::key_type</span>
           <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>                                      <span class="token comment">// unordered_map::mapped_type</span>
           <span class="token keyword">class</span> <span class="token class-name">Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>                       <span class="token comment">// unordered_map::hasher</span>
           <span class="token keyword">class</span> <span class="token class-name">Pred</span> <span class="token operator">=</span> equal_to<span class="token operator">&lt;</span>Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>                   <span class="token comment">// unordered_map::key_equal</span>
           <span class="token keyword">class</span> <span class="token class-name">Alloc</span> <span class="token operator">=</span> allocator<span class="token operator">&lt;</span> pair<span class="token operator">&lt;</span><span class="token keyword">const</span> Key<span class="token punctuation">,</span>T<span class="token operator">&gt;</span> <span class="token operator">&gt;</span>  <span class="token comment">// unordered_map::allocator_type</span>
           <span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">unordered_map</span><span class="token punctuation">;</span>
</code></pre></div><p>测试</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220701180341180.png" alt="image-20220701180341180"></p> <p>若扩容也是扩为两倍。</p> <h3 id="分配器测试"><a href="#分配器测试" class="header-anchor">#</a> 分配器测试</h3> <h4 id="allocator"><a href="#allocator" class="header-anchor">#</a> allocator</h4> <p>分配器用于分配存储空间，此处allocator是用于分配内存空间</p> <p>e.g.几个默认使用allocator作为分配器的STL库中类的声明</p> <p><code>vector</code> 源码声明</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;&gt;</span><span class="token comment">/* _Tp为数据类型，_Alloc为分配器类型，执行时确定类型 */</span>
<span class="token keyword">class</span> <span class="token class-name">vector</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _Vector_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">&gt;</span>
</code></pre></div><p><code>list</code> 源码声明</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">list</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _List_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">&gt;</span>
</code></pre></div><p><code>deque</code> 源码声明</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">deque</span> <span class="token operator">:</span> <span class="token keyword">protected</span> _Deque_base<span class="token operator">&lt;</span>_Tp<span class="token punctuation">,</span> _Alloc<span class="token operator">&gt;</span>
</code></pre></div><p><code>set</code> 源码声明 （后面的关联容器底层使用红黑树，所以需要有less仿函数来比较）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Key</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Compare</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>_Key<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">set</span>
<span class="token comment">/*_Key类型用于查找，后面的_Tp用于存放具体数据，less仿函数用于比较*/</span>
</code></pre></div><p><code>map</code> 源码声明</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Key</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">_Compare</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>less<span class="token operator">&lt;</span>_Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>
		<span class="token keyword">typename</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>_Key<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">map</span>
</code></pre></div><p><code>unordered_set</code> 源码声明（后面的无序容器底层使用哈希表实现）</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Value</span><span class="token punctuation">,</span>
		 <span class="token keyword">class</span> <span class="token class-name">_Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Value<span class="token operator">&gt;</span><span class="token punctuation">,</span>
		 <span class="token keyword">class</span> <span class="token class-name">_Pred</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>equal_to<span class="token operator">&lt;</span>_Value<span class="token operator">&gt;</span><span class="token punctuation">,</span>
		 <span class="token keyword">class</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>_Value<span class="token operator">&gt;&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">unordered_set</span>
<span class="token comment">/*_Value用于存放值，_Hash 用于确定哈希函数(根据_Value的值生成哈希值)，_Pred 用于比较值是否相等*/</span>
</code></pre></div><p><code>unordered_map</code> 源码声明</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">_Key</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">_Tp</span><span class="token punctuation">,</span>
		 <span class="token keyword">class</span> <span class="token class-name">_Hash</span> <span class="token operator">=</span> hash<span class="token operator">&lt;</span>_Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>
		 <span class="token keyword">class</span> <span class="token class-name">_Pred</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>equal_to<span class="token operator">&lt;</span>_Key<span class="token operator">&gt;</span><span class="token punctuation">,</span>
		 <span class="token keyword">class</span> <span class="token class-name">_Alloc</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>pair<span class="token operator">&lt;</span><span class="token keyword">const</span> _Key<span class="token punctuation">,</span> _Tp<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">unordered_map</span>
</code></pre></div><p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704100836946.png" alt="image-20220704100836946"></p> <p><strong>注意，只有当要申请小块空间时再使用malloc或者free，否则就用已经封装好了的库即可。</strong></p> <p><strong>同样，除了上述其情况，一般使用分配器</strong></p> <img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704102236270.png" alt="image-20220704102236270" style="zoom:80%;"> <h2 id="_4-c-stl体系结构"><a href="#_4-c-stl体系结构" class="header-anchor">#</a> 4 C++STL体系结构</h2> <blockquote><p>quote: 源码之前，了无秘密。</p> <p>Algorithms + Data Structures = Programs</p> <p>数据的属性 + 维护这个属性的操作 = Data Structure</p></blockquote> <h3 id="_4-1-c-源码文件布局"><a href="#_4-1-c-源码文件布局" class="header-anchor">#</a> 4.1 C++源码文件布局</h3> <img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704104016918.png" alt="image-20220704104016918" style="zoom:80%;"> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704104130353.png" alt="image-20220704104130353"></p> <h3 id="_4-2-oop-面向对象编程-vs-gp-泛型编程"><a href="#_4-2-oop-面向对象编程-vs-gp-泛型编程" class="header-anchor">#</a> 4.2 OOP（面向对象编程）vs. GP（泛型编程）</h3> <p><code>OOP = Object-Oriented programming</code></p> <p><code>GP = Generic programming</code></p> <p><strong>OOP与GP的最大区别：</strong></p> <ul><li><p><strong>OOP</strong>: 企图将 <strong>数据（data）</strong> 与 <strong>操作（methods）</strong> 联系在一起</p></li> <li><p><strong>GP</strong>: 却是将 <strong>数据</strong> 与 <strong>操作</strong> 分开来</p></li></ul> <p>例子：</p> <p>容器list不能使用::sort() 排序，所以它有自己的sort()</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704105842999.png" alt="image-20220704105842999"></p> <p><strong>采用GP的优点：</strong></p> <ul><li><strong>Containers</strong> 和 <strong>Algorithms</strong> 团队可各自闭门造车，其间以 <strong>Iterator</strong> 沟通即可</li> <li><strong>Algorithms</strong> 通过 <strong>Iterators</strong> 确定操作范围，并通过 <strong>Iterators</strong> 取用 <strong>Container</strong>元素</li></ul> <p>以下是例子：</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704105648270.png" alt="image-20220704105648270"></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">,</span> Compare comp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">comp</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">?</span> b <span class="token operator">:</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// comp可以作为仿函数，因为Compare重载了操作符括号 ()</span>
</code></pre></div><p><strong>所有algorithms，其内最终设计元素本身的操作，无非就是比大小。</strong></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704111022146.png" alt="image-20220704111022146"></p> <h3 id="_4-3-阅读c-stl的技术基础"><a href="#_4-3-阅读c-stl的技术基础" class="header-anchor">#</a> 4.3 阅读C++STL的技术基础</h3> <p><a href="https://zh.cppreference.com/w/cpp/language/operators" target="_blank" rel="noopener noreferrer"><strong>操作符重载（Operator Overloading)</strong><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>几个限制：</p> <ul><li><p>四个不能重载的操作符</p> <ul><li><p><code>::</code> (scope resolution)</p></li> <li><p><code>.</code> (member access)</p></li> <li><p><code>.*</code> (member access through pointer to member)</p></li> <li><p><code>?:</code> (ternary conditional)</p></li></ul></li> <li><p>不能创造C++未实现的操作符，如 <code>**, &lt;&gt;, &amp;|</code>之类</p></li> <li><p>运算符的优先级、结合方向或操作数的数量不会变化。</p></li> <li><p>重载的运算符 <strong>-&gt;</strong> 必须要么返回裸指针，要么（按引用或值）返回同样重载了运算符 <strong>-&gt;</strong> 的对象。</p></li> <li><p>运算符 **&amp;&amp;**与 <strong>||</strong> 的重载失去短路求值。</p></li> <li><p>C++17以前，<strong>&amp;&amp;</strong>、<strong>||</strong> 和 <strong>,</strong>（逗号）在被重载时失去它们特殊的<a href="https://zh.cppreference.com/w/cpp/language/eval_order" target="_blank" rel="noopener noreferrer">定序性质<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，并且即使不使用函数调用记法，也表现为与常规的函数调用相似。</p></li></ul> <table><thead><tr><th style="text-align:center;">表达式</th> <th style="text-align:center;">作为成员函数</th> <th style="text-align:center;">作为非成员函数</th> <th style="text-align:center;">示例</th></tr></thead> <tbody><tr><td style="text-align:center;">@a</td> <td style="text-align:center;">(a).operator@ ( )</td> <td style="text-align:center;">operator@ (a)</td> <td style="text-align:center;"><code>!std::cin</code> 调用 <code>std::cin.operator!()</code></td></tr> <tr><td style="text-align:center;">a@b</td> <td style="text-align:center;">(a).operator@ (b)</td> <td style="text-align:center;">operator@ (a, b)</td> <td style="text-align:center;"><code>std::cout&lt;&lt; 42</code> 调用 <code>std::cout.operator&lt;&lt;(42)</code></td></tr> <tr><td style="text-align:center;">a=b</td> <td style="text-align:center;">(a).operator= (b)</td> <td style="text-align:center;">不能是非成员</td> <td style="text-align:center;">给定 <code>std::string s;</code> ， <code>s = &quot;abc&quot;;</code> 调用 <code>s.operator=(&quot;abc&quot;)</code></td></tr> <tr><td style="text-align:center;">a(b...)</td> <td style="text-align:center;">(a).operator()(b...)</td> <td style="text-align:center;">不能是非成员</td> <td style="text-align:center;">给定 <code>std::random_device r;</code> ， <code>auto n = r();</code> 调用 <code>r.operator()()</code></td></tr> <tr><td style="text-align:center;">a[b]</td> <td style="text-align:center;">(a).operator<a href="b"></a></td> <td style="text-align:center;">不能是非成员</td> <td style="text-align:center;">给定 <code>std::map&lt;int, int&gt; m;</code> ， <code>m[1] = 2;</code> 调用 <code>m.operator[](1)</code></td></tr> <tr><td style="text-align:center;">a-&gt;</td> <td style="text-align:center;">(a).operator-&gt; ( )</td> <td style="text-align:center;">不能是非成员</td> <td style="text-align:center;">给定 <code>auto p = std::make_unique&lt;S&gt;();</code> <code>p-&gt;bar()</code> 调用 <code>p.operator-&gt;()</code></td></tr> <tr><td style="text-align:center;">a@</td> <td style="text-align:center;">(a).operator@ (0)</td> <td style="text-align:center;">operator@ (a, 0)</td> <td style="text-align:center;">给定 <code>std::vector&lt;int&gt;::iterator i = v.begin();</code> ， <code>i++</code> 调用 <code>i.operator++(0)</code></td></tr> <tr><td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td></tr></tbody></table> <p>在这张表中，<strong>@</strong> 是表示所有匹配运算符的占位符：<strong>@a</strong> 是所有前缀运算符，<strong>a@</strong> 是除 -&gt; 以外的所有后缀运算符，<strong>a@b</strong> 是除 = 以外的所有其他运算符。</p> <p>相关链接 <a href="http://zh.cppreference.com/w/cpp/numeric/random/random_device" target="_blank" rel="noopener noreferrer">std::random_device<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="http://zh.cppreference.com/w/cpp/string/basic_string" target="_blank" rel="noopener noreferrer">std::string<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="http://zh.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener noreferrer">std::map<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="http://zh.cppreference.com/w/cpp/memory/unique_ptr/make_unique" target="_blank" rel="noopener noreferrer">std::make_unique<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="http://zh.cppreference.com/w/cpp/io/cin" target="_blank" rel="noopener noreferrer">std::cin<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="http://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener noreferrer">std::vector<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>侯捷老师原话：你记得下来吗？反正我记不下来。当我们需要写的时候再去查找。</p></blockquote> <p><strong>模板（Templates）</strong></p> <p>见之前的文档。</p> <p>迭代器（泛化指针）的例子</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704152543733.png" alt="image-20220704152543733"></p> <p>模板可以自动推导类型</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704152628405.png" alt="image-20220704152628405"></p> <p>模板中特别要知道的：</p> <p><strong>泛化与特化</strong></p> <p>特化可以加快运行速度，突出template为空的情况</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704152949151.png" alt="image-20220704152949151"></p> <p>哈希中的特化</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704153024826.png" alt="image-20220704153024826"></p> <p>当类型为空时</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704153315782.png" alt="image-20220704153315782"></p> <p><strong>偏特化</strong></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220704153419907.png" alt="image-20220704153419907"></p> <h2 id="_5-c-stl源码剖析"><a href="#_5-c-stl源码剖析" class="header-anchor">#</a> 5 C++STL源码剖析</h2> <h3 id="_5-1-分配器allocators"><a href="#_5-1-分配器allocators" class="header-anchor">#</a> 5.1 分配器allocators</h3> <p>==先谈operator new() 和 malloc==</p> <p>C++一层层调用，最终会回到malloc这个函数，而malloc最终又会根据系统的不同进行底层的系统调用。</p> <p><strong>malloc</strong>的实现见博客 [【malloc的底层实现及原理】](![img](file:///C:\Users\F\AppData\Roaming\Tencent\QQ\Temp%W@GJ$ACOF(TYDYECOKVDYB.png)https://www.cnblogs.com/zpcoding/articles/10808969.html)</p> <p><strong>operator new</strong></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705091748989.png" alt="image-20220705091748989"></p> <p>旧版的allocator由于封装malloc与free过多层，造成开销过大；所以修改为使用SGI STL新实现的分配器。</p> <p>Gnu的分配器为了实现节省内存，他需要减少malloc的次数，所以设计了16条链表，每条链表负责不同大小的区块，第0条链表负责的是8字节大小区块，第一条负责16字节大小的区块，以此类推....所以在容器需要内存的时候，内存中元素的大小会被分配器调整到8的倍数，然后再具体确定选择哪一条链表。</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705095346253.png" alt="image-20220705095346253"></p> <p>G4.9版使用的分配器（又换回以前开销大的了）</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705100624089.png" alt="image-20220705100624089"></p> <p>但G4.9所附带的标准库，有许多extenion allocators，其中__pool_alloc 就是G2.9的alloc，我们仍然可以使用它。</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705101552826.png" alt="image-20220705101552826"></p> <p>在G4.9中，我们像右上角那样设置分配器即可使用这个更优秀的分配器，e.g.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>vector<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> __gun_cxx<span class="token double-colon punctuation">::</span>__pool_alloc<span class="token operator">&lt;</span>string<span class="token operator">&gt;&gt;</span> vec<span class="token punctuation">;</span>
</code></pre></div><p>亲测，本人用的g++8.1.0中，使用的默认分配器仍然是较差的那个；不过也仍有__pool_alloc这个分配器，用法相同，其在编译器中的路径如下</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705104514436.png" alt="image-20220705104514436"></p> <blockquote><p>侯捷老师原话：他为什么要换回这个较差的分配器，我没办法给他找理由，他们也没有出来解释说明。</p></blockquote> <p>但是std::allocator从c++20起就正式废除了。</p> <h3 id="_5-2-容器之间的实现关系与分类"><a href="#_5-2-容器之间的实现关系与分类" class="header-anchor">#</a> 5.2 容器之间的实现关系与分类</h3> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705105638349.png" alt="image-20220705105638349"></p> <h3 id="_5-3-容器list"><a href="#_5-3-容器list" class="header-anchor">#</a> 5.3 容器list</h3> <p><strong>list容器本身的实现</strong></p> <p>这是核心</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705110828545.png" alt="image-20220705110828545"></p> <p><strong>list的迭代器（iterator）实现</strong></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705114017882.png" alt="image-20220705114017882"></p> <p>注意前置++与后置++的区别</p> <p><strong>前置++ (prefix form)</strong>：前置++返回原来对象的引用</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>self<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> <span class="token punctuation">(</span>link_type<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>后置++ (post form)</strong>: 后置++返回对象</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>slef <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self tmp <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token operator">++</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>后置自增会调用重载的前置自增来实现，其调用过程图解如下：</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705115043373.png" alt="image-20220705115043373"></p> <p>泛化指针在其内部重载操作符++，用于从节点内部跳转到下一个节点而不是单纯自增地址。</p> <p><strong>list的迭代器中还实现了*和-&gt;的重载</strong></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705142641845.png" alt="image-20220705142641845"></p> <p>下面是一个测试，直接返回一个对象，而函数返回值设置为引用，那么可以得到该对象的引用。</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">CC</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> data<span class="token punctuation">;</span>
    <span class="token function">CC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    CC c<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> tmp <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此处tmp的类型为整型的引用</span>
    cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>data <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    tmp <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> tmp<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
输出结果为
<span class="token number">1</span>
<span class="token number">10</span>
</code></pre></div><p><strong>G4.9版本就有了很多改进</strong></p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705145129759.png" alt="image-20220705145129759"></p> <p>G4.9版本的list容器设计如下：</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20220705151423464.png" alt="image-20220705151423464"></p> <p><code>begin()</code>指向第一个节点，<code>end()</code>指向最后一个节点的下一块（前闭后开）</p> <h3 id="_5-4-迭代器的设计原则和iterator-traits的作用与设计"><a href="#_5-4-迭代器的设计原则和iterator-traits的作用与设计" class="header-anchor">#</a> 5.4 迭代器的设计原则和Iterator Traits的作用与设计</h3> <p>iterator本质是个结构体，但是其</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20230225230942105.png" alt="image-20230225230942105"></p> <p>Iterator的设计原则：</p> <ul><li>iterators必须有回答 algorithms 的能力</li></ul> <p>目前C++的iterator必须提出五种 associated types</p> <ul><li>iterator_category</li> <li>difference_type</li> <li>value_type</li> <li>reference</li> <li>pointer</li></ul> <p>如下：</p> <p><img src="https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20230225233248414.png" alt="image-20230225233248414"></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cs-basis/2_EffectiveC++.html" class="prev">
        EffectiveC++
      </a></span> <span class="next"><a href="/cs-basis/4_ComputerNetwork.html">
        计算机网络
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.72c8bf2a.js" defer></script><script src="/assets/js/2.2702b4bf.js" defer></script><script src="/assets/js/15.db6a460d.js" defer></script>
  </body>
</html>
