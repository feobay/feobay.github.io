(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{289:function(_,v,t){"use strict";t.r(v);var s=t(14),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"操作系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[_._v("#")]),_._v(" 操作系统")]),_._v(" "),v("p",[_._v("主要为经典面试题，大部分来自小林coding。")]),_._v(" "),v("h2",{attrs:{id:"虚拟内存与物理内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存与物理内存"}},[_._v("#")]),_._v(" 虚拟内存与物理内存")]),_._v(" "),v("p",[_._v("见博客 "),v("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1924147#:~:text=%E6%A0%B9%E6%9C%AC%E5%8C%BA%E5%88%AB%EF%BC%9A%E8%BF%9B%E7%A8%8B%E6%98%AF,%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D",target:"_blank",rel:"noopener noreferrer"}},[_._v("进程与线程的对比"),v("OutboundLink")],1)]),_._v(" "),v("p",[v("strong",[_._v("Linux用户空间内存结构")])]),_._v(" "),v("img",{staticStyle:{zoom:"67%"},attrs:{src:"https://img-blog.csdnimg.cn/img_convert/7b5b6b3728acde8df019350df3cb85c1.png",alt:"图片"}}),_._v(" "),v("ul",[v("li",[_._v("程序文件段，包括二进制可执行代码；")]),_._v(" "),v("li",[_._v("已初始化数据段，包括静态常量；")]),_._v(" "),v("li",[_._v("未初始化数据段，包括未初始化的静态变量；")]),_._v(" "),v("li",[_._v("堆段，包括动态分配的内存，从低地址开始向上增长；")]),_._v(" "),v("li",[_._v("文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关 ）；")]),_._v(" "),v("li",[_._v("栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 "),v("code",[_._v("8 MB")]),_._v("。当然系统也提供了参数，以便我们自定义大小；")])]),_._v(" "),v("p",[_._v("在这 6 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 "),v("code",[_._v("malloc()")]),_._v(" 或者 "),v("code",[_._v("mmap()")]),_._v(" ，就可以分别在堆和文件映射段动态分配内存。")]),_._v(" "),v("p",[v("strong",[_._v("虚拟内存")]),_._v("与"),v("strong",[_._v("物理内存")])]),_._v(" "),v("p",[_._v("虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的"),v("strong",[_._v("虚拟内存")]),_._v("，当然我们知道最终进程的数据及代码必然要放到"),v("strong",[_._v("物理内存")]),_._v("上，那么必须有某种机制能记住虚拟地址空间中的某个数据被放到了哪个物理内存地址上，这就是所谓的"),v("strong",[_._v("地址空间映射")]),_._v("，也就是虚拟内存地址与物理内存地址的映射关系。")]),_._v(" "),v("p",[_._v("操作系统实现虚拟内存到物理内存的映射方式："),v("strong",[_._v("页表")])]),_._v(" "),v("p",[_._v("页表中记录了虚拟内存地址到物理内存地址的映射关系。")]),_._v(" "),v("p",[v("strong",[_._v("把虚拟地址转换为物理地址需要查找页表")]),_._v("，页表查找是一个"),v("strong",[_._v("很慢")]),_._v("的过程，因此通常使用：")]),_._v(" "),v("p",[v("font",{attrs:{color:"red"}},[_._v(" Cache来缓存常用的地址映射，这样可以加速页表的查找，这个Cache就是TLB")])],1),_._v(" "),v("p",[v("strong",[_._v("TLB本质上就是一个cache，是用来加速页表查找的")]),_._v("。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么：")]),_._v(" "),v("p",[v("font",{attrs:{color:"red"}},[_._v(" 当进程切换后页表也要进行切换，页表切换后TLB就失效了")])],1),_._v(" "),v("p",[v("font",{attrs:{color:"red"}},[_._v(" cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢")])],1),_._v(" "),v("p",[v("strong",[_._v("表现出来的就是程序运行会变慢")]),_._v("，而"),v("strong",[_._v("线程切换则不会导致TLB失效")]),_._v("，"),v("strong",[_._v("因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。")])]),_._v(" "),v("p",[v("strong",[_._v("总结：")])]),_._v(" "),v("p",[_._v("每个进程拥有自己的、私有的、连续的虚拟内存，而同一进程下的线程共享同一块虚拟内存。")]),_._v(" "),v("p",[_._v("虚拟内存靠页表来存储与物理内存的映射关系，它们的转换需要查找页表，同时还通过Cache（此处是TLB）存储一些常用的映射关系来加快虚拟内存与物理内存的转换；但是进程切换会切换虚拟内存，因此TLB就失效了，这导致Cache命中率降低，虚拟地址与物理地址的转换就变慢，进而引起程序运行速度下降；而切换线程不会切换虚拟内存空间，所以就不会引起内存的转换。")]),_._v(" "),v("h2",{attrs:{id:"进程与线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程与线程"}},[_._v("#")]),_._v(" 进程与线程")]),_._v(" "),v("blockquote",[v("p",[_._v("需要了解一下 进程, 线程状态转换, 信息的保存")]),_._v(" "),v("p",[_._v("要熟悉一下 PCB进程控制块 以及 寄存器 和 计数器")])]),_._v(" "),v("p",[v("strong",[_._v("进程与线程的本质区别：")])]),_._v(" "),v("p",[_._v("进程是操作系统资源分配的最基本单位，而线程是任务调度和执行的基本单位。")]),_._v(" "),v("p",[_._v("进程具体知识见博客：")]),_._v(" "),v("p",[v("a",{attrs:{href:"https://blog.51cto.com/u_15279775/2937622",target:"_blank",rel:"noopener noreferrer"}},[v("strong",[_._v("【操作系统/OS笔记08】进程的定义、组成、PCB、生命周期管理、状态变化模型、挂起模型")]),v("OutboundLink")],1)]),_._v(" "),v("p",[v("strong",[_._v("进程拥有的资源")])]),_._v(" "),v("p",[_._v("进程拥有的资源都存放在 $PCB(Process , Control , Block)$ 中，PCB也是进程的唯一标识。其控制的资源包括：")]),_._v(" "),v("ul",[v("li",[v("p",[v("strong",[_._v("进程标识符")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("外部标识符")]),_._v("：方便用户对进程的访问。PID")]),_._v(" "),v("li",[v("strong",[_._v("内部标识符")]),_._v("：方便操作系统对进程的使用，即OS赋予每个进程唯一的数字标识，它通常是一个进程的序号。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("处理机状态（又称进程上下文）")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("通用寄存器")]),_._v("：又称用户可视寄存器，可以被用户程序访问，用于暂存信息。")]),_._v(" "),v("li",[v("strong",[_._v("指令计数器")]),_._v("：存放要访问的下一条指令的地址。")]),_._v(" "),v("li",[v("strong",[_._v("程序状态字寄存器")]),_._v("$PSW(Process , State , Word)$：存放状态信息（如条件码、执行方式、中断屏蔽标志等）")]),_._v(" "),v("li",[v("strong",[_._v("用户栈指针寄存器")]),_._v("：每个用户进程都有一个或者多个与之相关的系统栈，用于存放进程和系统的 "),v("strong",[_._v("调用参数及调用地址")]),_._v("。栈指针指向该栈的栈顶。")])]),_._v(" "),v("p",[v("font",{attrs:{color:"red"}},[_._v("当处理机处于执行状态时，正在处理的许多信息都存放在寄存器中；而当寄存器被切换时，处理机的咋状态信息都存放在PCB中，以便在该进程被重新调度时，能再从断点处继续执行。")])],1)]),_._v(" "),v("li",[v("p",[v("strong",[_._v("进程调度信息")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("进程状态")]),_._v("：创建，**就绪（静态[被挂起]-活动就绪[被激活]），执行，阻塞（静态[被挂起]-活动[被激活]就绪），**终止")]),_._v(" "),v("li",[v("strong",[_._v("进程优先级")]),_._v("：进程抢占处理机的优先级")]),_._v(" "),v("li",[v("strong",[_._v("进程调度所需其它信息")]),_._v("：进程已等待CPU时间总和、进程已执行时间总和等；这些信息与它们所采用的调度算法相关")]),_._v(" "),v("li",[v("strong",[_._v("事件")]),_._v("：进程阻塞的原因，详细描述就是 进程由执行状态转换为阻塞状态所等待发生的事件。")])])]),_._v(" "),v("li",[v("p",[v("strong",[_._v("进程控制信息")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("程序和数据的地址")]),_._v("：进程中程序和数据的内存或外存起始地址，便于再次调度该进程时快速从PCB中找到程序与数据。")]),_._v(" "),v("li",[v("strong",[_._v("进程同步和通信机制")]),_._v("：实现进程同步或通信时所必须的机制，如消息队列指针、信号量等的全部或部分会放入PCB。")]),_._v(" "),v("li",[v("strong",[_._v("资源清单")]),_._v("：列出进程在运行期间所需的全部资源（除CPU外）")]),_._v(" "),v("li",[v("strong",[_._v("链接指针")]),_._v("：给出本进程所在队列的下一个进程PCB的起始地址。（也是PCB通过链表组织的实现结构）")])])])]),_._v(" "),v("p",[v("strong",[_._v("控制线程同步的方法")])]),_._v(" "),v("p",[v("strong",[_._v("有那几种锁")])]),_._v(" "),v("p",[v("strong",[_._v("线程池的实现？")])]),_._v(" "),v("h2",{attrs:{id:"malloc分配方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#malloc分配方式"}},[_._v("#")]),_._v(" malloc分配方式")]),_._v(" "),v("p",[_._v("见小林coding博客 "),v("a",{attrs:{href:"https://xiaolincoding.com/os/3_memory/malloc.html#malloc-%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%9A%84",target:"_blank",rel:"noopener noreferrer"}},[_._v("malloc是如何分配内存的"),v("OutboundLink")],1)]),_._v(" "),v("h3",{attrs:{id:"malloc有两种分配方式-brk-和-mmap"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#malloc有两种分配方式-brk-和-mmap"}},[_._v("#")]),_._v(" malloc有两种分配方式，"),v("strong",[_._v("brk()")]),_._v(" 和 "),v("strong",[_._v("mmap()")])]),_._v(" "),v("ul",[v("li",[_._v("当分配内存大于128kb时会调用brk，"),v("em",[_._v("通过将「堆顶」指针向高地址移动，获得新的内存空间；且释放的空间"),v("strong",[_._v("不归还给操作系统")]),_._v("，而是缓存在malloc的内存池中")])]),_._v(" "),v("li",[v("em",[_._v("申请内存大于128kb时调用 mmap()，通过mmap()系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存；free后空间"),v("strong",[_._v("归还给操作系统")]),_._v("，这块虚拟内存不再属于该进程")])])]),_._v(" "),v("p",[_._v("注意，不同的 glibc 版本定义的阈值也是不同的。")]),_._v(" "),v("h3",{attrs:{id:"malloc是直接物理分配么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#malloc是直接物理分配么"}},[_._v("#")]),_._v(" "),v("strong",[_._v("malloc是直接物理分配么？")])]),_._v(" "),v("p",[v("strong",[_._v("malloc分配不是直接物理分配的，malloc分配的是虚拟内存")]),_._v("，如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。")]),_._v(" "),v("p",[_._v("只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后操作系统会建立虚拟内存和物理内存之间的映射关系。")]),_._v(" "),v("h3",{attrs:{id:"为什么不全部使用malloc分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不全部使用malloc分配"}},[_._v("#")]),_._v(" "),v("strong",[_._v("为什么不全部使用malloc分配？")])]),_._v(" "),v("p",[v("strong",[_._v("首先是避免频繁系统调用")])]),_._v(" "),v("p",[_._v("因为向操作系统申请内存，是要通过系统调用的，执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。")]),_._v(" "),v("p",[_._v("所以，申请内存的操作应该避免频繁的系统调用，如果都用 mmap 来分配内存，等于每次都要执行系统调用。")]),_._v(" "),v("p",[v("strong",[_._v("其次是减少缺页中断")])]),_._v(" "),v("p",[_._v("因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。会导致CPU消耗过大。")]),_._v(" "),v("p",[v("strong",[_._v("改进这两个问题")])]),_._v(" "),v("p",[_._v("malloc 通过 brk() 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。")]),_._v(" "),v("p",[_._v("**等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数。**降低CPU消耗。")]),_._v(" "),v("h3",{attrs:{id:"为什么不全部用brk来分配"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么不全部用brk来分配"}},[_._v("#")]),_._v(" 为什么不全部用brk来分配？")]),_._v(" "),v("p",[_._v("前面我们提到通过 brk 从堆空间分配的内存，并不会归还给操作系统，那么我们那考虑这样一个场景。")]),_._v(" "),v("p",[_._v("如果我们连续申请了 10k，20k，30k 这三片内存，如果 10k 和 20k 这两片释放了，变为了空闲内存空间，如果下次申请的内存小于 30k，那么就可以重用这个空闲内存空间。（此时就是在内存池中重用）")]),_._v(" "),v("p",[_._v("但是如果下次申请的内存大于 30k，没有可用的空闲内存空间，必须向 OS 申请，实际使用内存继续增大。")]),_._v(" "),v("p",[_._v("因此，随着系统频繁地 malloc 和 free ，尤其对于小块内存，**堆内将产生越来越多不可用的碎片，导致“内存泄露”。**而这种“泄露”现象使用 "),v("strong",[_._v("valgrind 是无法检测出来的")]),_._v("。")]),_._v(" "),v("p",[_._v("所以，malloc 实现中，充分考虑了 brk 和 mmap 行为上的差异及优缺点，默认分配大块内存 (128KB) 才使用 mmap 分配内存空间。")]),_._v(" "),v("h3",{attrs:{id:"free-函数只传入一个内存地址-为什么能知道要释放多大的内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#free-函数只传入一个内存地址-为什么能知道要释放多大的内存"}},[_._v("#")]),_._v(" free() 函数只传入一个内存地址，为什么能知道要释放多大的内存？")]),_._v(" "),v("p",[_._v("前面提到， malloc 返回给用户态的内存起始地址比进程的堆空间起始地址多了 16 字节.")]),_._v(" "),v("p",[_._v("这个多出来的 16 字节就是保存了该内存块的描述信息，比如有该内存块的大小。")]),_._v(" "),v("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://img-blog.csdnimg.cn/img_convert/cb6e3ce4532ff0a6bfd60fe3e52a806e.png",alt:"图片"}}),_._v(" "),v("p",[_._v("这样当执行 free() 函数时，free 会对传入进来的内存地址向左偏移 16 字节，然后从这个 16 字节的分析出当前的内存块的大小，自然就知道要释放多大的内存了。")]),_._v(" "),v("h2",{attrs:{id:"网路系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网路系统"}},[_._v("#")]),_._v(" 网路系统")]),_._v(" "),v("h3",{attrs:{id:"什么是dma技术"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是dma技术"}},[_._v("#")]),_._v(" 什么是DMA技术？")]),_._v(" "),v("p",[v("strong",[_._v("没有DMA之前的I/O过程：")])]),_._v(" "),v("ul",[v("li",[_._v("CPU 发出对应的指令给磁盘控制器，然后返回；")]),_._v(" "),v("li",[_._v("磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个"),v("strong",[_._v("中断")]),_._v("；")]),_._v(" "),v("li",[_._v("CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/I_O%20%E4%B8%AD%E6%96%AD.png",alt:"I_O 中断"}})]),_._v(" "),v("p",[_._v("整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。这很明显会影响CPU的工作效率，所以就有了 "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("直接内存访问（Direct Memory Access）")])]),_._v("技术。")],1),_._v(" "),v("p",[v("strong",[_._v("什么是DMA？")])]),_._v(" "),v("p",[_._v("在进行I/O设备和内存数据传输时，数据搬运的工作全部交给"),v("strong",[_._v("DMA控制器")]),_._v("，而CPU不再参与任何与数据搬运相关的事情，这样CPU就可以去处理别的事务。")]),_._v(" "),v("p",[_._v("使用 DMA 控制器进行数据传输的过程如下：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/DRM%20I_O%20%E8%BF%87%E7%A8%8B.png",alt:"DRM I_O 过程"}})]),_._v(" "),v("p",[_._v("具体过程：")]),_._v(" "),v("ul",[v("li",[_._v("用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；")]),_._v(" "),v("li",[_._v("操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；")]),_._v(" "),v("li",[_._v("DMA 进一步将 I/O 请求发送给磁盘；")]),_._v(" "),v("li",[_._v("磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；")]),_._v(" "),v("li",[v("strong",[_._v("DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务")]),_._v("；")]),_._v(" "),v("li",[_._v("当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；")]),_._v(" "),v("li",[_._v("CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；")])]),_._v(" "),v("p",[_._v("整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。现代计算机中一般每个I/O设备都有自己的DMA控制器。")]),_._v(" "),v("h3",{attrs:{id:"如何优化文件传输性能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何优化文件传输性能"}},[_._v("#")]),_._v(" 如何优化文件传输性能？")]),_._v(" "),v("p",[v("strong",[_._v("要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("1.先来看看，如何减少「用户态与内核态的上下文切换」的次数呢？")])]),_._v(" "),v("p",[_._v("读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。")]),_._v(" "),v("p",[_._v("而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。")]),_._v(" "),v("p",[_._v("所以，"),v("font",{attrs:{color:"red"}},[v("strong",[_._v("要想减少上下文切换到次数，就要减少系统调用的次数")]),_._v("。")])],1),_._v(" "),v("p",[v("strong",[_._v("2.再来看看，如何减少「数据拷贝」的次数？")])]),_._v(" "),v("p",[_._v("在前面我们知道了，传统的文件传输方式会历经 4 次数据拷贝，而且这里面，「从内核的读缓冲区拷贝到用户的缓冲区里，再从用户的缓冲区里拷贝到 socket 的缓冲区里」，这个过程是没有必要的。")]),_._v(" "),v("p",[_._v("因为文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此"),v("strong",[_._v("用户的缓冲区是没有必要存在的")]),_._v("。")]),_._v(" "),v("h3",{attrs:{id:"如何实现零拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何实现零拷贝"}},[_._v("#")]),_._v(" 如何实现零拷贝？")]),_._v(" "),v("p",[_._v("零拷贝的实现有两种方式：")]),_._v(" "),v("ul",[v("li",[_._v("mmap + write")]),_._v(" "),v("li",[_._v("sendfile")])]),_._v(" "),v("p",[v("strong",[_._v("mmap + write")])]),_._v(" "),v("p",[_._v("在前面我们知道，"),v("code",[_._v("read()")]),_._v(" 系统调用的过程中会把内核缓冲区的数据拷贝到用户的缓冲区里，于是为了减少这一步开销，我们可以用 "),v("code",[_._v("mmap()")]),_._v(" 替换 "),v("code",[_._v("read()")]),_._v(" 系统调用函数。")]),_._v(" "),v("div",{staticClass:"language-cpp extra-class"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[_._v("buf "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("mmap")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("file"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" len"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("write")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("sockfd"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" buf"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" len"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])]),v("p",[v("code",[_._v("mmap()")]),_._v(" 系统调用函数会直接把内核缓冲区里的数据「"),v("strong",[_._v("映射")]),_._v("」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。[进程内存模型，代码段，数据段（.data .bass），堆（低地址到高地址生长），"),v("strong",[_._v("文件映射区")]),_._v("，栈（高地址到低地址生长），内核空间] mmap映射到文件映射区。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/mmap_write.png",alt:"mmap_write"}})]),_._v(" "),v("p",[_._v("具体过程如下：")]),_._v(" "),v("ul",[v("li",[_._v("应用进程调用了 "),v("code",[_._v("mmap()")]),_._v(" 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核**「共享」**这个缓冲区；")]),_._v(" "),v("li",[_._v("应用进程再调用 "),v("code",[_._v("write()")]),_._v("，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；")]),_._v(" "),v("li",[_._v("最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。")])]),_._v(" "),v("p",[_._v("通过使用 "),v("code",[_._v("mmap()")]),_._v(" 来代替 "),v("code",[_._v("read()")]),_._v("， 可以减少一次数据拷贝的过程。")]),_._v(" "),v("p",[v("strong",[_._v("但这还不是最理想的零拷贝")]),_._v("，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。")]),_._v(" "),v("p",[v("strong",[_._v("sendfile")])]),_._v(" "),v("p",[_._v("在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 "),v("code",[_._v("sendfile()")]),_._v("，函数形式如下：")]),_._v(" "),v("div",{staticClass:"language-cpp extra-class"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[v("span",{pre:!0,attrs:{class:"token macro property"}},[v("span",{pre:!0,attrs:{class:"token directive-hash"}},[_._v("#")]),v("span",{pre:!0,attrs:{class:"token directive keyword"}},[_._v("include")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[_._v("<sys/socket.h>")])]),_._v("\nssize_t "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("sendfile")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" out_fd"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" in_fd"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" off_t "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("*")]),_._v("offset"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" size_t count"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])]),v("p",[_._v("它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。")]),_._v(" "),v("p",[_._v("首先，它可以替代前面的 "),v("code",[_._v("read()")]),_._v(" 和 "),v("code",[_._v("write()")]),_._v(" 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。")]),_._v(" "),v("p",[_._v("其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png",alt:"senfile-3次拷贝"}})]),_._v(" "),v("p",[_._v("但是这还不是真正的零拷贝技术，如果网卡支持 SG-DMA（"),v("em",[_._v("The Scatter-Gather Direct Memory Access")]),_._v("）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。")]),_._v(" "),v("p",[_._v("你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：")]),_._v(" "),v("div",{staticClass:"language-sh extra-class"},[v("pre",{pre:!0,attrs:{class:"language-sh"}},[v("code",[_._v("$ "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("ethtool")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token parameter variable"}},[_._v("-k")]),_._v(" eth0 "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("|")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("grep")]),_._v(" scatter-gather\nscatter-gather: on\n")])])]),v("p",[_._v("于是，从 Linux 内核 "),v("code",[_._v("2.4")]),_._v(" 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， "),v("code",[_._v("sendfile()")]),_._v(" 系统调用的过程发生了点变化，具体过程如下：")]),_._v(" "),v("ul",[v("li",[_._v("第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；")]),_._v(" "),v("li",[_._v("第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；")])]),_._v(" "),v("p",[_._v("所以，这个过程之中，只进行了 2 次数据拷贝，如下图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png",alt:"senfile-零拷贝"}})]),_._v(" "),v("p",[_._v("这就是所谓的"),v("strong",[_._v("零拷贝（"),v("em",[_._v("Zero-copy")]),_._v("）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。")])]),_._v(" "),v("p",[_._v("零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，"),v("strong",[_._v("只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。")])]),_._v(" "),v("p",[_._v("所以，总体来看，"),v("strong",[_._v("零拷贝技术可以把文件传输的性能提高至少一倍以上。")])]),_._v(" "),v("h3",{attrs:{id:"使用零拷贝的项目"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用零拷贝的项目"}},[_._v("#")]),_._v(" 使用零拷贝的项目")]),_._v(" "),v("p",[_._v("Kafka，Nginx等。")]),_._v(" "),v("p",[v("strong",[_._v("补充：")])]),_._v(" "),v("ul",[v("li",[_._v("PageCache：是磁盘和主存之间的缓存，用于缓存和预读磁盘中的数据，可以充分发挥程序的局部性。")]),_._v(" "),v("li",[_._v("大文件传输：大文件不使用PageCache，PageCache只能缓存少量数据，造成命中率降低，这样造成巨大额外开销。")]),_._v(" "),v("li",[_._v("使用异步I/O可以绕开PageCache")])]),_._v(" "),v("p",[_._v("异步I/O的流程：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%BC%82%E6%AD%A5IO%E7%9A%84%E8%BF%87%E7%A8%8B.png",alt:"异步IO的过程"}})]),_._v(" "),v("p",[_._v("它把读操作分为两部分：")]),_._v(" "),v("ul",[v("li",[_._v("前半部分，内核向磁盘发起读请求，但是可以"),v("strong",[_._v("不等待数据就位就可以返回")]),_._v("，于是进程此时可以处理其他任务；")]),_._v(" "),v("li",[_._v("后半部分，当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的"),v("strong",[_._v("通知")]),_._v("，再去处理数据；")])]),_._v(" "),v("p",[_._v("我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。")]),_._v(" "),v("p",[_._v("绕开 PageCache 的 I/O 叫"),v("strong",[_._v("直接 I/O")]),_._v("，使用 PageCache 的 I/O 则叫"),v("strong",[_._v("缓存 I/O")]),_._v("。")]),_._v(" "),v("p",[_._v("大文件的传输不应该使用 PageCache，因为可能由于 PageCache 被大文件占据，而导致「热点」小文件无法利用到 PageCache。")]),_._v(" "),v("p",[_._v("于是，"),v("strong",[_._v("在高并发的场景下，针对大文件的传输的方式，应该使用「异步 I/O + 直接 I/O」来替代零拷贝技术")]),_._v("。")]),_._v(" "),v("p",[_._v("直接 I/O 应用场景常见的两种：")]),_._v(" "),v("ul",[v("li",[_._v("应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；")]),_._v(" "),v("li",[_._v("传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。")])]),_._v(" "),v("p",[_._v("另外，由于直接 I/O 绕过了 PageCache，就无法享受内核的这两点的优化：")]),_._v(" "),v("ul",[v("li",[_._v("内核的 I/O 调度算法会缓存尽可能多的 I/O 请求在 PageCache 中，最后「"),v("strong",[_._v("合并")]),_._v("」成一个更大的 I/O 请求再发给磁盘，这样做是为了减少磁盘的寻址操作；")]),_._v(" "),v("li",[_._v("内核也会「"),v("strong",[_._v("预读")]),_._v("」后续的 I/O 请求放在 PageCache 中，一样是为了减少对磁盘的操作")])]),_._v(" "),v("p",[_._v("于是，传输大文件的时候，使用「异步 I/O + 直接 I/O」了，就可以无阻塞地读取文件了。")]),_._v(" "),v("p",[_._v("所以，传输文件的时候，我们要根据文件的大小来使用不同的方式：")]),_._v(" "),v("ul",[v("li",[_._v("传输大文件的时候，使用「异步 I/O + 直接 I/O」；")]),_._v(" "),v("li",[_._v("传输小文件的时候，则使用「零拷贝技术」；")])]),_._v(" "),v("p",[_._v("在 nginx 中，我们可以用如下配置，来根据文件的大小来使用不同的方式：")]),_._v(" "),v("div",{staticClass:"language-cpp extra-class"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[_._v("location "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v("video"),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v(" \n    sendfile on"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" \n    aio on"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" \n    directio "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("1024")]),_._v("m"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" \n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n")])])]),v("p",[_._v("当文件大小大于 "),v("code",[_._v("directio")]),_._v(" 值后，使用「异步 I/O + 直接 I/O」，否则使用「零拷贝技术」。")]),_._v(" "),v("h3",{attrs:{id:"i-o-多路复用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#i-o-多路复用"}},[_._v("#")]),_._v(" I/O 多路复用")]),_._v(" "),v("p",[v("strong",[_._v("socket四元组：")])]),_._v(" "),v("p",[_._v("TCP/IP协议用一个四元组来唯一确定一个连接：")]),_._v(" "),v("ol",[v("li",[_._v("服务器的IP")]),_._v(" "),v("li",[_._v("服务器的Port")]),_._v(" "),v("li",[_._v("客户端的IP")]),_._v(" "),v("li",[_._v("客户端的Port")])]),_._v(" "),v("p",[_._v("服务器的IP和Port可以保持不变，只要客户端的IP和Port彼此不同就OK了。")]),_._v(" "),v("p",[_._v("一个TCP连接的标记为一个四元组：")]),_._v(" "),v("p",[v("code",[_._v("(source_ip, source_port, destination_ip, destination_port)")])]),_._v(" "),v("p",[_._v("即(源IP，源端口，目的IP，目的端口)四个元素的组合。")]),_._v(" "),v("p",[_._v("进一步的理解：")]),_._v(" "),v("p",[_._v("也可以在同一个端口号和IP地址上绑定一个TCP套接字和一个UDP套接字")]),_._v(" "),v("p",[_._v("原因在于端口号虽然一样，但由于协议不一样，所以端口是完全独立的")]),_._v(" "),v("p",[_._v("tcp/udp一般采用五元组来定位一个连接:")]),_._v(" "),v("p",[v("code",[_._v("src_ip, src_port, dest_ip, dest_port, protocol_type")])]),_._v(" "),v("blockquote",[v("p",[_._v("一个端口号可以同时被两个使用udp或tcp的进程同时绑定吗?")]),_._v(" "),v("p",[v("strong",[_._v("可以")]),_._v("，protocol_type不一样，不是两个相同的链接。")])]),_._v(" "),v("p",[v("strong",[_._v("Linux系统调用socket")])]),_._v(" "),v("p",[_._v("此处不聊socket的使用，只聊TCP使用socket的流程及每一步的作用")]),_._v(" "),v("p",[_._v("服务端首先调用 "),v("code",[_._v("socket()")]),_._v(" 函数，创建一个网络协议为 IPv4、传输协议为TCP的Socket文件描述符（sockfd），接着调用 "),v("code",[_._v("bind()")]),_._v(" 函数，给这个Socket绑定一个IP地址和端口，"),v("strong",[_._v("绑定这两个的目的是什么？")])]),_._v(" "),v("ul",[v("li",[_._v("绑定端口的目的：当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到我们的应用程序，然后把数据传递给我们。")]),_._v(" "),v("li",[_._v("绑定 IP 地址的目的：一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给我们；")])]),_._v(" "),v("blockquote",[v("p",[_._v("总结bind()的目的就是，绑定ip:port，以便机器通过ip找到收到的数据包；通过port找到服务端机器上对应的进程。")])]),_._v(" "),v("p",[_._v("绑定完 IP 地址和端口后，就可以调用 "),v("code",[_._v("listen()")]),_._v(" 函数进行监听，此时对应 TCP 状态图中的 "),v("code",[_._v("listen")]),_._v("，如果我们要判定服务器中一个网络程序有没有启动，可以通过 "),v("code",[_._v("netstat")]),_._v(" 命令查看对应的端口号是否有被监听。")]),_._v(" "),v("p",[_._v("服务端进入了监听状态后，通过调用 "),v("code",[_._v("accept()")]),_._v(" 函数，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。")]),_._v(" "),v("p",[_._v("那客户端是怎么发起连接的呢？客户端在创建好 Socket 后，调用 "),v("code",[_._v("connect()")]),_._v(" 函数发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后万众期待的 TCP 三次握手就开始了。")]),_._v(" "),v("p",[_._v("在 TCP 连接的过程中，"),v("strong",[_._v("服务器的内核")]),_._v("实际上为每个 Socket 维护了"),v("strong",[_._v("两个队列")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("一个是「还没完全建立」连接的队列，称为 "),v("strong",[_._v("TCP半连接队列")]),_._v("，这个队列都是"),v("strong",[_._v("没有完成三次握手")]),_._v("的连接，此时服务端处于 "),v("code",[_._v("syn_rcvd")]),_._v(" 的状态；")]),_._v(" "),v("li",[_._v("一个是「已经建立」连接的队列，称为 "),v("strong",[_._v("TCP全连接队列")]),_._v("，这个队列都是"),v("strong",[_._v("完成了三次握手")]),_._v("的连接，此时服务端处于 "),v("code",[_._v("established")]),_._v(" 状态")])]),_._v(" "),v("p",[_._v("当 TCP 全连接队列不为空后，服务端的 "),v("code",[_._v("accept()")]),_._v(" 函数，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 Socket 返回应用程序，后续数据传输都用这个 Socket。")]),_._v(" "),v("p",[_._v("注意，监听的 Socket 和真正用来传数据的 Socket 是两个：")]),_._v(" "),v("ul",[v("li",[_._v("一个叫作"),v("strong",[_._v("监听 Socket")]),_._v("；（listen状态后的sockfd")]),_._v(" "),v("li",[_._v("一个叫作"),v("strong",[_._v("已连接 Socket")]),_._v("；（accept返回的sockfd")])]),_._v(" "),v("p",[_._v("连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过 "),v("code",[_._v("read()")]),_._v(" 和 "),v("code",[_._v("write()")]),_._v(" 函数来读写数据。")]),_._v(" "),v("p",[_._v("至此， TCP 协议的 Socket 程序的调用过程就结束了，整个过程如下图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/tcp_socket.png",alt:"tcp_socket"}})]),_._v(" "),v("p",[_._v("看到这，不知道你有没有觉得读写 Socket 的方式，好像读写文件一样。")]),_._v(" "),v("p",[_._v("是的，基于 Linux 一切皆文件的理念，在内核中 Socket 也是以「文件」的形式存在的，也是有对应的文件描述符。")]),_._v(" "),v("p",[v("strong",[_._v("关于文件描述符")])]),_._v(" "),v("p",[_._v("文件描述符的作用是什么？"),v("strong",[_._v("每一个进程都有一个数据结构 "),v("code",[_._v("task_struct")]),_._v("，该结构体里有一个指向「文件描述符数组」的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。")])]),_._v(" "),v("p",[_._v("然后"),v("strong",[_._v("每个文件都有一个 inode")]),_._v("，"),v("strong",[_._v("Socket 文件的 inode")]),_._v(" 指向了"),v("strong",[_._v("内核中的 Socket 结构")]),_._v("，在这个结构体里有"),v("strong",[_._v("两个队列")]),_._v("，分别是"),v("strong",[_._v("发送队列")]),_._v("和"),v("strong",[_._v("接收队列")]),_._v("，这个两个队列里面保存的是一个个 "),v("code",[_._v("struct sk_buff")]),_._v("，用链表的组织形式串起来。")]),_._v(" "),v("p",[_._v("sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层我们叫 packet，在数据链路层称为 frame。")]),_._v(" "),v("p",[_._v("**你可能会好奇，为什么全部数据包只用一个结构体来描述呢？**协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，"),v("strong",[_._v("如果每一层都用一个结构体")]),_._v("，那在层之间传递数据的时候，"),v("strong",[_._v("就要发生多次拷贝")]),_._v("，这将大大降低 CPU 效率。")]),_._v(" "),v("p",[_._v("于是，为了在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 sk_buff 中 "),v("code",[_._v("data")]),_._v(" 的指针，比如：")]),_._v(" "),v("ul",[v("li",[_._v("当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐步剥离协议首部。")]),_._v(" "),v("li",[_._v("当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb->data 的值来增加协议首部。")])]),_._v(" "),v("p",[_._v("从下面这张图看到，当发送报文时，data 指针的移动过程。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/sk_buff.png",alt:"sk_buff"}})]),_._v(" "),v("p",[v("strong",[_._v("如何一台机器如何服务更多的用户？")])]),_._v(" "),v("p",[_._v("前面提到的 TCP Socket 调用流程是最简单、最基本的，它基本只能一对一通信，因为使用的是"),v("strong",[_._v("同步阻塞")]),_._v("的方式，当服务端在还没处理完一个客户端的网络 I/O 时，或者 读写操作发生阻塞时，其他客户端是无法与服务端连接的。")]),_._v(" "),v("p",[_._v("可如果我们服务器只能服务一个客户，那这样就太浪费资源了，于是我们要改进这个网络 I/O 模型，以支持更多的客户端。")]),_._v(" "),v("p",[_._v("在改进网络 I/O 模型前，我先来提一个问题，你知道服务器单机理论最大能连接多少个客户端？")]),_._v(" "),v("p",[_._v("相信你知道 TCP 连接是由四元组唯一确认的，这个四元组就是："),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("本机IP, 本机端口, 对端IP, 对端端口")]),_._v("。")])],1),_._v(" "),v("p",[_._v("服务器作为服务方，通常会在本地固定监听一个端口，等待客户端的连接。因此服务器的本地 IP 和端口是固定的，于是对于服务端 TCP 连接的四元组只有对端 IP 和端口是会变化的，所以 "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("最大 TCP 连接数 = 客户端 IP 数×客户端端口数")])]),_._v("。")],1),_._v(" "),v("p",[_._v("对于 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("服务端单机最大 TCP 连接数约为 2 的 48 次方")])]),_._v("。")],1),_._v(" "),v("p",[_._v("这个理论值相当“丰满”，但是服务器肯定承载不了那么大的连接数，主要会受两个方面的限制：")]),_._v(" "),v("ul",[v("li",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("文件描述符")])]),_._v("，Socket 实际上是一个文件，也就会对应一个文件描述符。在 Linux 下，单个进程打开的文件描述符数是有限制的，没有经过修改的值一般都是 1024，不过我们可以通过 ulimit 增大文件描述符的数目；")],1),_._v(" "),v("li",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("系统内存")])]),_._v("，每个 TCP 连接在内核中都有对应的数据结构，意味着每个连接都是会占用一定内存的；")],1)]),_._v(" "),v("p",[_._v("那如果服务器的内存只有 2 GB，网卡是千兆的，能支持并发 1 万请求吗？")]),_._v(" "),v("p",[_._v("并发 1 万请求，也就是经典的 C10K 问题 ，C 是 Client 单词首字母缩写，C10K 就是单机同时处理 1 万个请求的问题。")]),_._v(" "),v("p",[_._v("从硬件资源角度看，对于 2GB 内存千兆网卡的服务器，如果每个请求处理占用不到 200KB 的内存和 100Kbit 的网络带宽就可以满足并发 1 万个请求。")]),_._v(" "),v("p",[_._v("不过，要想真正实现 C10K 的服务器，要考虑的地方在于服务器的网络 I/O 模型，效率低的模型，会加重系统开销，从而会离 C10K 的目标越来越远。")]),_._v(" "),v("p",[v("strong",[_._v("多进程模型")])]),_._v(" "),v("p",[_._v("基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用"),v("strong",[_._v("多进程模型")]),_._v("，也就是为每个客户端分配一个进程来处理请求。")]),_._v(" "),v("p",[_._v("服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 "),v("code",[_._v("fork()")]),_._v(" 函数创建一个子进程，实际上就把父进程"),v("strong",[_._v("所有")]),_._v("相关的东西都"),v("strong",[_._v("复制")]),_._v("一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。")]),_._v(" "),v("p",[_._v("这两个进程刚复制完的时候，几乎一模一样。不过，会根据"),v("strong",[_._v("返回值")]),_._v("来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。")]),_._v(" "),v("p",[_._v("正因为子进程会"),v("strong",[_._v("复制父进程的文件描述符")]),_._v("，于是就可以直接使用「已连接 Socket 」和客户端通信了，")]),_._v(" "),v("p",[_._v("可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。")]),_._v(" "),v("p",[_._v("下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png",alt:"多进程"}})]),_._v(" "),v("p",[_._v("另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成"),v("strong",[_._v("僵尸进程")]),_._v("，随着僵尸进程越多，会慢慢耗尽我们的系统资源。")]),_._v(" "),v("p",[_._v("因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 "),v("code",[_._v("wait()")]),_._v(" 和 "),v("code",[_._v("waitpid()")]),_._v(" 函数。")]),_._v(" "),v("p",[_._v("这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为"),v("strong",[_._v("每产生一个进程，必会占据一定的系统资源")]),_._v("，而且"),v("strong",[_._v("进程间上下文切换的“包袱”是很重的")]),_._v("，性能会大打折扣。")]),_._v(" "),v("p",[_._v("进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。")]),_._v(" "),v("p",[v("strong",[_._v("多线程模型")])]),_._v(" "),v("p",[_._v("既然进程间上下文切换的“包袱”很重，那我们就搞个比较轻量级的模型来应对多用户的请求 —— "),v("strong",[_._v("多线程模型")]),_._v("。")]),_._v(" "),v("p",[_._v("线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，而只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。")]),_._v(" "),v("p",[_._v("当服务器与客户端 TCP 完成连接后，通过 "),v("code",[_._v("pthread_create()")]),_._v(" 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。")]),_._v(" "),v("p",[_._v("如果每来一个连接就创建一个线程，线程运行完后，还得操作系统还得销毁线程，虽说线程切换的上写文开销不大，但是如果频繁创建和销毁线程，系统开销也是不小的。")]),_._v(" "),v("p",[_._v("那么，我们可以使用"),v("strong",[_._v("线程池")]),_._v("的方式来避免线程的频繁创建和销毁，所谓的线程池，就是提前创建若干个线程，这样当由新连接建立时，将这个已连接的 Socket 放入到一个队列里，然后线程池里的线程负责从队列中取出「已连接 Socket 」进行处理。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png",alt:"线程池"}})]),_._v(" "),v("p",[_._v("需要注意的是，这个队列是全局的，每个线程都会操作，为了避免多线程竞争，线程在操作这个队列前要加锁。（多线程竞争也就是"),v("strong",[_._v("惊群效应")]),_._v("）")]),_._v(" "),v("p",[_._v("上面基于进程或者线程模型的，其实还是有问题的。新到来一个 TCP 连接，就需要分配一个进程或者线程，那么如果要达到 C10K，意味着要一台机器维护 1 万个连接，相当于要维护 1 万个进程/线程，操作系统就算死扛也是扛不住的。")]),_._v(" "),v("p",[v("strong",[_._v("I/O多路复用")])]),_._v(" "),v("p",[_._v("既然为每个请求分配一个进程/线程的方式不合适，那有没有可能只使用一个进程来维护多个 Socket 呢？答案是有的，那就是 "),v("strong",[_._v("I/O 多路复用")]),_._v("技术。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.png",alt:"多路复用"}})]),_._v(" "),v("p",[_._v("一个进程虽然任一时刻只能处理一个请求，但是处理每个请求的事件时，耗时控制在 1 毫秒以内，这样 1 秒内就可以处理上千个请求，把时间拉长来看，多个请求复用了一个进程，这就是多路复用，这种思想很类似一个 CPU 并发多个进程，所以也叫做时分多路复用。")]),_._v(" "),v("p",[_._v("我们熟悉的 select/poll/epoll 内核提供给用户态的多路复用系统调用，"),v("strong",[_._v("进程可以通过一个系统调用函数从内核中获取多个事件")]),_._v("。")]),_._v(" "),v("p",[_._v("select/poll/epoll 是如何获取网络事件的呢？在获取事件时，先把所有连接（文件描述符）传给内核，再由内核返回产生了事件的连接，然后在用户态中再处理这些连接对应的请求即可。")]),_._v(" "),v("p",[_._v("select/poll/epoll 这是三个多路复用接口，都能实现 C10K 吗？接下来，我们分别说说它们。")]),_._v(" "),v("p",[v("strong",[_._v("select/poll")])]),_._v(" "),v("p",[_._v("select 实现多路复用的方式是，将已连接的 Socket 都放到一个"),v("strong",[_._v("文件描述符集合")]),_._v("（这个文件描述符集合就是个数组），然后调用 select 函数将文件描述符集合"),v("strong",[_._v("拷贝")]),_._v("到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过"),v("strong",[_._v("遍历")]),_._v("文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合"),v("strong",[_._v("拷贝")]),_._v("回用户态里，然后用户态还需要再通过"),v("strong",[_._v("遍历")]),_._v("的方法找到可读或可写的 Socket，然后再对其处理。")]),_._v(" "),v("p",[_._v("所以，对于 select 这种方式，需要进行 "),v("strong",[_._v("2 次「遍历」文件描述符集合")]),_._v("，一次是在内核态里，一个次是在用户态里 ，而且还会发生 "),v("strong",[_._v("2 次「拷贝」文件描述符集合")]),_._v("，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。")]),_._v(" "),v("p",[_._v("select 使用固定长度的 BitsMap，表示文件描述符集合，而且所支持的文件描述符的个数是有限制的，在 Linux 系统中，由内核中的 FD_SETSIZE 限制， 默认最大值为 "),v("code",[_._v("1024")]),_._v("，只能监听 0~1023 的文件描述符。")]),_._v(" "),v("p",[_._v("poll 不再用 BitsMap 来存储所关注的文件描述符，取而代之用动态数组，以"),v("strong",[_._v("链表")]),_._v("形式来组织，突破了 select 的文件描述符个数限制，当然还会受到系统文件描述符限制。")]),_._v(" "),v("p",[_._v("但是 poll 和 select 并没有太大的本质区别，"),v("strong",[_._v("都是使用「线性结构」存储进程关注的 Socket 集合，因此都需要遍历文件描述符集合来找到可读或可写的 Socket，时间复杂度为 O(n)，而且也需要在用户态与内核态之间拷贝文件描述符集合")]),_._v("，这种方式随着并发数上来，性能的损耗会呈指数级增长。")]),_._v(" "),v("p",[v("strong",[_._v("epoll")])]),_._v(" "),v("p",[_._v("先复习下 epoll 的用法。如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。")]),_._v(" "),v("div",{staticClass:"language-cpp extra-class"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" s "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("socket")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("AF_INET"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" SOCK_STREAM"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("0")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("bind")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("listen")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("s"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" epfd "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("epoll_create")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("epoll_ctl")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("epfd"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(",")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("//将所有需要监听的socket添加到epfd中")]),_._v("\n\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("while")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("int")]),_._v(" n "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("=")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[_._v("epoll_wait")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[_._v("for")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("接收到数据的socket"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("{")]),_._v("\n        "),v("span",{pre:!0,attrs:{class:"token comment"}},[_._v("//处理")]),_._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("}")]),_._v("\n")])])]),v("p",[_._v("epoll 通过两个方面，很好解决了 select / poll 的问题。")]),_._v(" "),v("p",[v("em",[_._v("第一点")]),_._v("，epoll 在内核里使用"),v("strong",[_._v("红黑树来跟踪进程所有待检测的文件描述字")]),_._v("，把需要监控的 socket 通过 "),v("code",[_._v("epoll_ctl()")]),_._v(" 函数加入内核中的红黑树里，红黑树是个高效的数据结构，增删改一般时间复杂度是 "),v("code",[_._v("O(logn)")]),_._v("。而 select/poll 内核里没有类似 epoll 红黑树这种保存所有待检测的 socket 的数据结构，所以 select/poll 每次操作时都传入整个 socket 集合给内核，而 epoll 因为在内核维护了红黑树，可以保存所有待检测的 socket ，所以只需要传入一个待检测的 socket，减少了内核和用户空间大量的数据拷贝和内存分配。")]),_._v(" "),v("p",[v("em",[_._v("第二点")]),_._v("， epoll 使用"),v("strong",[_._v("事件驱动")]),_._v("的机制，内核里"),v("strong",[_._v("维护了一个链表来记录就绪事件")]),_._v("，当某个 socket 有事件发生时，通过"),v("strong",[_._v("回调函数")]),_._v("内核会将其加入到这个就绪事件列表中，当用户调用 "),v("code",[_._v("epoll_wait()")]),_._v(" 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。")]),_._v(" "),v("p",[_._v("从下图你可以看到 epoll 相关的接口作用：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/epoll.png",alt:"epoll"}})]),_._v(" "),v("p",[v("strong",[_._v("边缘触发和水平触发")])]),_._v(" "),v("p",[_._v("epoll 支持两种触发模式，"),v("strong",[v("font",{attrs:{color:"blue"}},[_._v("边缘触发（edge-triggered, ET）和 水平触发（level-triggered, LT）")])],1)]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("边缘触发")]),_._v("：当被监控的 Socket 描述符上有可读事件发生时，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("服务器只会从 epoll_wait 中苏醒一次")])]),_._v("，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此程序员要保证一次性将内核缓冲区的数据读完，如果该数据到达时没来得及处理，就直接丢弃；")],1),_._v(" "),v("li",[v("strong",[_._v("水平触发")]),_._v("：当被监控的 Socket 上有可读事件发生时，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("服务器端不断地从 epoll_wait 中苏醒，知道内核缓冲区数据被 read 函数读取完毕才结束")])]),_._v("，目的是告诉我们有数据需要读取；")],1)]),_._v(" "),v("p",[_._v("例如，")]),_._v(" "),v("p",[_._v("你的快递被放到了一个快递箱里，如果快递箱只会通过短信通知你一次，即使你一直没有去取，它也不会再发送第二条短信提醒你，这个方式就是边缘触发；")]),_._v(" "),v("p",[_._v("如果快递箱发现你的快递没有被取出，它就会不停地发短信通知你，直到你取出了快递，它才消停，这个就是水平触发的方式。")]),_._v(" "),v("p",[v("strong",[_._v("边缘触发一般搭配非阻塞I/O使用的原因？")])]),_._v(" "),v("blockquote",[v("p",[_._v("使用边缘触发时，I/O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据，以免错失读写的机会。因此，我们会循环从文件描述符读写数据，那么如果文件描述符是阻塞的，没有数据可读写时进程就会一直阻塞在读写函数那里，程序就没有办法往下继续执行。所以需要边缘触发要搭配非阻塞I/O使用，程序会一直执行 I/O 操作，直到系统调用（如 "),v("code",[_._v("read")]),_._v(" 和 "),v("code",[_._v("write")]),_._v("）返回错误，错误类型为 "),v("code",[_._v("EAGAIN")]),_._v(" 或 "),v("code",[_._v("EWOULDBLOCK")]),_._v("。")])]),_._v(" "),v("p",[v("code",[_._v("EAGAIN")]),_._v(" 就是当文件描述符为非阻塞模式时，read操作从中进行读取数据时没有数据可读，那么此时read操作不会阻塞在那里等待有数据可读，而是直接返回 "),v("code",[_._v("EAGAIN")]),_._v(" 提示其进行下一次调用。（在VxWorks和Windows上，EAGAIN的名字叫做 "),v("code",[_._v("EWOULDBLOCK")]),_._v("）")]),_._v(" "),v("p",[v("strong",[_._v("一般来说，边缘触发的效率比水平触发的效率要高的原因？")])]),_._v(" "),v("blockquote",[v("p",[_._v("因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。")])]),_._v(" "),v("p",[_._v("select/poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。")]),_._v(" "),v("p",[_._v("另外，"),v("strong",[_._v("使用 I/O 多路复用时，最好搭配非阻塞 I/O 一起使用")]),_._v("，Linux 手册关于 select 的内容中有如下说明：")]),_._v(" "),v("blockquote",[v("p",[_._v('Under Linux, select() may report a socket file descriptor as "ready for reading", while nevertheless a subsequent read blocks. This could for example happen when data has arrived but upon examination has wrong checksum and is discarded. There may be other circumstances in which a file descriptor is spuriously reported as ready. Thus it may be safer to use O_NONBLOCK on sockets that should not block.')])]),_._v(" "),v("p",[_._v("博主 小林coding 翻译的结果：")]),_._v(" "),v("blockquote",[v("p",[_._v('在Linux下，select() 可能会将一个 socket 文件描述符报告为 "准备读取"，而后续的读取块却没有。例如，当数据已经到达，但经检查后发现有错误的校验和而被丢弃时，就会发生这种情况。也有可能在其他情况下，文件描述符被错误地报告为就绪。因此，在不应该阻塞的 socket 上使用 O_NONBLOCK 可能更安全。')])]),_._v(" "),v("p",[_._v("简单理解就是，"),v("strong",[_._v("多路复用API返回的事件并不一定是可读写的")]),_._v("，如果使用阻塞I/O，那么在调用 read/write 时则会发生程序阻塞 I/O，以便应对极少数的特殊情况。")]),_._v(" "),v("p",[v("strong",[_._v("I/O 多路复用总结")])]),_._v(" "),v("p",[_._v("最基础的 TCP 的 Socket 编程，它是阻塞 I/O 模型，基本上只能一对一通信，为了服务更多的用户，需要改进模型。")]),_._v(" "),v("p",[_._v("这就引入了 "),v("strong",[_._v("多进程/多线程模型")]),_._v("，每来一个客户端连接，就分配一个进程/线程，然后后续的读写都在对应的进程/线程，这种方式处理100个客户端没问题，但是当客户端增大到10000个时，10000个进程/线程的调度、上下文切换及它们占用的内存开销巨大，都会称为这种模型的性能瓶颈。")]),_._v(" "),v("p",[_._v("为解决上述问题，就有了 "),v("strong",[_._v("I/O多路复用")]),_._v("，可以只在"),v("strong",[_._v("一个进程里处理多个文件的I/O")]),_._v("，Linux 下有三种提供了 I/O 多路复用的 API，分别是：select、poll、epoll。")]),_._v(" "),v("p",[_._v("select和poll没有本质区别，它们内部都是通过 ⌈线性结构⌋ 来存储进程监听的 Socket文件描述符集合。")]),_._v(" "),v("p",[_._v("在使用时，首先需要把监听的 Socket 集合通过 select/poll 系统调用从用户态拷贝到内核态，然后由内核检测事件，当有网络事件产生时，内核需要遍历进程监听的 Socket 集合，找到对应的 Socket，并设置其状态为可读/可写，然后把整个 Socket 集合从内核态拷贝到用户态，然后由用户进程遍历监听的 Socket 集合找到可读/写的 Socket，然后对其处理。")]),_._v(" "),v("p",[_._v("select 和 poll 的缺陷在于，当客户端越多，也就是 Socket 集合越大，Socket 集合的遍历和拷贝会带来很大的开销，因此也很难应对 C10K。")]),_._v(" "),v("p",[_._v("epoll 是解决 C10K 问题的利器，通过两个方面解决了 select/poll 的问题。")]),_._v(" "),v("ul",[v("li",[_._v("epoll 内核使用了 "),v("strong",[_._v("红黑树")]),_._v(" 来存储进程所有待检测的 Socket，红黑树的增删查改效率都为 O(logn)较快，通过红黑树管理，不需要像 select/poll 一样每次都要将 socket 集合来回拷贝，极大减少了内核和用户空间的内存分配和数据拷贝。")]),_._v(" "),v("li",[_._v("epoll 是 "),v("strong",[_._v("事件驱动")]),_._v(" 的机制，内核中维护了一个 "),v("strong",[_._v("链表")]),_._v(" 来记录就绪事件，只将有事件发生的 Socket 集合传递给应用程序，不需要像 select/poll 那样轮询扫描整个集合（包含有和无事件的 Socket ），大大提高了检测的效率。")])]),_._v(" "),v("p",[_._v("而且，epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。")]),_._v(" "),v("h3",{attrs:{id:"高性能网络模型-reactor-和-proactor"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高性能网络模型-reactor-和-proactor"}},[_._v("#")]),_._v(" 高性能网络模型：Reactor 和 Proactor")]),_._v(" "),v("p",[_._v("Reactor 模式也叫 "),v("code",[_._v("Dispatcher")]),_._v(" 模式，这个名字更贴合该模式的含义，即 "),v("strong",[_._v("I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程")]),_._v("。")]),_._v(" "),v("p",[_._v("Reactor 模式主要由 Reactor 和处理资源池这两个核心部分组成:")]),_._v(" "),v("ul",[v("li",[_._v("Reactor 负责监听和分发事件，事件类型包含连接事件、读写事件；")]),_._v(" "),v("li",[_._v("处理资源池负责处理事件，如read -> 业务逻辑 -> send;")])]),_._v(" "),v("p",[_._v("Reactor 模式是灵活多变的，可以应对不同的业务场景，灵活在于：")]),_._v(" "),v("ul",[v("li",[_._v("Reactor 的数量可以只有一个，也可以有多个；")]),_._v(" "),v("li",[_._v("处理资源池可以是单个进程 / 线程， 也可以是多个 进程 / 线程")])]),_._v(" "),v("p",[_._v("排列组合一下就是：")]),_._v(" "),v("ul",[v("li",[_._v("单 Reactor 单进程 / 线程；")]),_._v(" "),v("li",[_._v("单 Reactor 多进程 / 线程；")]),_._v(" "),v("li",[_._v("多 Reactor 单进程 / 线程；")]),_._v(" "),v("li",[_._v("多 Reactor 多进程 / 线程；")])]),_._v(" "),v("p",[_._v("其中，「多 Reactor 单进程 / 线程」实现方案相比「单 Reactor 单进程 / 线程」方案，不仅复杂而且也没有性能优势，因此实际中并没有应用。")]),_._v(" "),v("p",[_._v("剩下的 3 个方案都是比较经典的，且都有应用在实际的项目中：")]),_._v(" "),v("ul",[v("li",[_._v("单 Reactor 单进程 / 线程；")]),_._v(" "),v("li",[_._v("单 Reactor 多线程 / 进程；")]),_._v(" "),v("li",[_._v("多 Reactor 多进程 / 线程；")])]),_._v(" "),v("p",[_._v("方案具体使用进程还是线程，要看使用的编程语言以及平台有关：")]),_._v(" "),v("ul",[v("li",[_._v("Java 语言一般使用线程，比如 Netty;")]),_._v(" "),v("li",[_._v("C 语言使用进程和线程都可以，例如 Nginx 使用的是进程，Memcache 使用的是线程。")])]),_._v(" "),v("p",[_._v("接下来，分别介绍这三个经典的 Reactor 方案。")]),_._v(" "),v("p",[_._v("一般来说，C 语言实现的是「"),v("strong",[_._v("单 Reactor *单进程*")]),_._v("」的方案，因为 C 语编写完的程序，运行后就是一个独立的进程，不需要在进程中再创建线程。")]),_._v(" "),v("p",[_._v("而 Java 语言实现的是「"),v("strong",[_._v("单 Reactor *单线程*")]),_._v("」的方案，因为 Java 程序是跑在 Java 虚拟机这个进程上面的，虚拟机中有很多线程，我们写的 Java 程序只是其中的一个线程而已。")]),_._v(" "),v("p",[v("strong",[_._v("单Reactor 单进程")])]),_._v(" "),v("p",[_._v("我们来看看「"),v("strong",[_._v("单 Reactor 单进程")]),_._v("」的方案示意图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%8D%95Reactor%E5%8D%95%E8%BF%9B%E7%A8%8B.png",alt:"单Reactor单进程"}})]),_._v(" "),v("p",[_._v("可以看到进程里有 "),v("strong",[_._v("Reactor、Acceptor、Handler")]),_._v(" 这三个对象：")]),_._v(" "),v("ul",[v("li",[_._v("Reactor 对象的作用是监听和分发事件；")]),_._v(" "),v("li",[_._v("Acceptor 对象的作用是获取连接；")]),_._v(" "),v("li",[_._v("Handler 对象的作用是处理业务；")])]),_._v(" "),v("p",[_._v("对象里的 select、accept、read、send 是系统调用函数，dispatch 和 「业务处理」是需要完成的操作，其中 dispatch 是分发事件操作。")]),_._v(" "),v("p",[_._v("接下来，介绍下「单 Reactor 单进程」这个方案：")]),_._v(" "),v("ul",[v("li",[_._v("Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；")]),_._v(" "),v("li",[_._v("如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；")]),_._v(" "),v("li",[_._v("如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；")]),_._v(" "),v("li",[_._v("Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。")])]),_._v(" "),v("p",[_._v("单 Reactor 单进程的方案因为全部工作都在同一个进程内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。")]),_._v(" "),v("p",[_._v("但是，这种方案存在 2 个缺点：")]),_._v(" "),v("ul",[v("li",[_._v("第一个缺点，因为只有一个进程，"),v("strong",[_._v("无法充分利用 多核 CPU 的性能")]),_._v("；")]),_._v(" "),v("li",[_._v("第二个缺点，Handler 对象在业务处理时，整个进程是无法处理其他连接的事件的，"),v("strong",[_._v("如果业务处理耗时比较长，那么就造成响应的延迟")]),_._v("；")])]),_._v(" "),v("p",[_._v("所以，单 Reactor 单进程的方案"),v("strong",[_._v("不适用计算机密集型的场景，只适用于业务处理非常快速的场景")]),_._v("。")]),_._v(" "),v("p",[_._v("Redis 是由 C 语言实现的，在 Redis 6.0 版本之前采用的正是「单 Reactor 单进程」的方案，因为 Redis 业务处理主要是在内存中完成，操作的速度是很快的，性能瓶颈不在 CPU 上，所以 Redis 对于命令的处理是单进程的方案。")]),_._v(" "),v("p",[v("strong",[_._v("单 Reactor 多线程 / 多进程")])]),_._v(" "),v("p",[_._v("如果要克服「单 Reactor 单线程 / 进程」方案的缺点，那么就需要引入多线程 / 多进程，这样就产生了"),v("strong",[_._v("单 Reactor 多线程 / 多进程")]),_._v("的方案。")]),_._v(" "),v("p",[_._v("闻其名不如看其图，先来看看「单 Reactor 多线程」方案的示意图如下：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png",alt:"单Reactor多线程"}})]),_._v(" "),v("p",[_._v("详细说一下这个方案：")]),_._v(" "),v("ul",[v("li",[_._v("Reactor 对象通过 select （IO 多路复用接口） 监听事件，收到事件后通过 dispatch 进行分发，具体分发给 Acceptor 对象还是 Handler 对象，还要看收到的事件类型；")]),_._v(" "),v("li",[_._v("如果是连接建立的事件，则交由 Acceptor 对象进行处理，Acceptor 对象会通过 accept 方法 获取连接，并创建一个 Handler 对象来处理后续的响应事件；")]),_._v(" "),v("li",[_._v("如果不是连接建立事件， 则交由当前连接对应的 Handler 对象来进行响应；")])]),_._v(" "),v("p",[_._v("上面的三个步骤和单 Reactor 单线程方案是一样的，接下来的步骤就开始不一样了：")]),_._v(" "),v("ul",[v("li",[_._v("Handler 对象不再负责业务处理，只负责数据的接收和发送，Handler 对象通过 read 读取到数据后，会将数据发给子线程里的 Processor 对象进行业务处理；")]),_._v(" "),v("li",[_._v("子线程里的 Processor 对象就进行业务处理，处理完后，将结果发给主线程中的 Handler 对象，接着由 Handler 通过 send 方法将响应结果发送给 client；")])]),_._v(" "),v("p",[_._v("单 Reator 多线程的方案优势在于"),v("strong",[_._v("能够充分利用多核 CPU 的能")]),_._v("，那既然引入多线程，那么自然就带来了多线程竞争资源的问题。")]),_._v(" "),v("p",[_._v("例如，子线程完成业务处理后，要把结果传递给主线程的 Handler 进行发送，这里涉及共享数据的竞争。")]),_._v(" "),v("p",[_._v("要避免多线程由于竞争共享资源而导致数据错乱的问题，就需要在操作共享资源前加上互斥锁，以保证任意时间里只有一个线程在操作共享资源，待该线程操作完释放互斥锁后，其他线程才有机会操作共享数据。")]),_._v(" "),v("p",[_._v("聊完单 Reactor 多线程的方案，接着来看看单 Reactor 多进程的方案。")]),_._v(" "),v("p",[_._v("事实上，单 Reactor 多进程相比单 Reactor 多线程实现起来很麻烦，主要因为要考虑子进程 <-> 父进程的双向通信，并且父进程还得知道子进程要将数据发送给哪个客户端。")]),_._v(" "),v("p",[_._v("而多线程间可以共享数据，虽然要额外考虑并发问题，但是这远比进程间通信的复杂度低得多，因此实际应用中也"),v("strong",[_._v("看不到单 Reactor 多进程的模式。")])]),_._v(" "),v("p",[_._v("另外，「单 Reactor」的模式还有个问题，"),v("strong",[_._v("因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方")]),_._v("。")]),_._v(" "),v("p",[v("strong",[_._v("多 Reactor 多进程 / 线程")])]),_._v(" "),v("p",[_._v("要解决「单 Reactor」的问题，就是将「单 Reactor」实现成「多 Reactor」，这样就产生了第 "),v("strong",[_._v("多 Reactor 多进程 / 线程")]),_._v("的方案。")]),_._v(" "),v("p",[_._v("老规矩，闻其名不如看其图。多 Reactor 多进程 / 线程方案的示意图如下（以线程为例）：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png",alt:"主从Reactor多线程"}})]),_._v(" "),v("p",[_._v("方案详细说明如下：")]),_._v(" "),v("ul",[v("li",[_._v("主线程中的 MainReactor 对象通过 select 监控连接建立事件，收到事件后通过 Acceptor 对象中的 accept 获取连接，将新的连接分配给某个子线程；")]),_._v(" "),v("li",[_._v("子线程中的 SubReactor 对象将 MainReactor 对象分配的连接加入 select 继续进行监听，并创建一个 Handler 用于处理连接的响应事件。")]),_._v(" "),v("li",[_._v("如果有新的事件发生时，SubReactor 对象会调用当前连接对应的 Handler 对象来进行响应。")]),_._v(" "),v("li",[_._v("Handler 对象通过 read -> 业务处理 -> send 的流程来完成完整的业务流程。")])]),_._v(" "),v("p",[_._v("多 Reactor 多线程的方案虽然看起来复杂的，但是实际实现时比单 Reactor 多线程的方案要简单的多，原因如下：")]),_._v(" "),v("ul",[v("li",[_._v("主线程和子线程分工明确，主线程只负责接收新连接，子线程负责完成后续的业务处理。")]),_._v(" "),v("li",[_._v("主线程和子线程的交互很简单，主线程只需要把新连接传给子线程，子线程无须返回数据，直接就可以在子线程将处理结果发送给客户端。")])]),_._v(" "),v("p",[_._v("大名鼎鼎的两个开源软件 Netty 和 Memcache 都采用了「多 Reactor 多线程」的方案。")]),_._v(" "),v("p",[_._v("采用了「多 Reactor 多进程」方案的开源软件是 Nginx，不过方案与标准的多 Reactor 多进程有些差异。")]),_._v(" "),v("p",[_._v("具体差异表现在主进程中仅仅用来初始化 socket，并没有创建 mainReactor 来 accept 连接，而是由子进程的 Reactor 来 accept 连接，通过锁来控制一次只有一个子进程进行 accept（防止出现惊群现象），子进程 accept 新连接后就放到自己的 Reactor 进行处理，不会再分配给其他子进程。")]),_._v(" "),v("p",[v("strong",[_._v("Proactor")])]),_._v(" "),v("p",[_._v("Reactor 是非阻塞同步网络模式，而 Proactor 是异步网络模式。")]),_._v(" "),v("p",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("阻塞I / O")])]),_._v("，当用户进程执行 "),v("code",[_._v("read")]),_._v("，线程会被阻塞，一直等待内核数据准备好，并把数据从内核缓从内核缓冲区拷贝到应用程序的缓冲区中，拷贝完成后，read调用才会返回。"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("阻塞等待的是 ⌈内核数据准备好⌋ 和 ⌈数据从内核态拷贝到用户态⌋ 这两个过程。")])])],1),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E9%98%BB%E5%A1%9E%20I_O.png",alt:"阻塞 I_O"}})]),_._v(" "),v("p",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("非阻塞I / O")])]),_._v("，非阻塞read在数据未准备好时立即返回，此时应用程序不断轮询查看内核数据是否准备好，没准备好就立即返回，当内核数据准备好时，再将数据从内核缓冲区拷贝到程序缓冲区，"),v("code",[_._v("read")]),_._v(" 调用才会有结果。"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("此时最后一次read调用，从内核态获取数据到用户态的过程，是一个同步操作，是需要等待的过程。这里同步，就是指数据从内核态拷贝到用户态的过程。")])]),_._v("(将Socket设置为 "),v("code",[_._v("O_NONBLOCK")]),_._v(" ，就表示该文件描述符读写方式为非阻塞)")],1),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E9%9D%9E%E9%98%BB%E5%A1%9E%20I_O%20.png",alt:"非阻塞 I_O "}})]),_._v(" "),v("p",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("异步I / O")])]),_._v(" 则是「内核数据准备好」和「数据从内核态拷贝到用户态」这"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("两个过程都不用等待")])]),_._v("。当我们发起 "),v("code",[_._v("aio_read")]),_._v(" (异步I/O) 之后，就立即返回，内核自动将数据从内核态拷贝到用户空间，这个拷贝过程同样是异步的，内核自动完成的，和前面的同步操作不一样，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("应用程序不需要主动发起拷贝动作。")])])],1),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%BC%82%E6%AD%A5%20I_O.png",alt:"异步 I_O"}})]),_._v(" "),v("p",[_._v("Proactor 正是采用了异步 I/O 技术，所以被称为异步网络模型。")]),_._v(" "),v("ul",[v("li",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("Reactor 是非阻塞同步模型，感知的是就绪可读可写事件")])]),_._v("。每次感知到有事件发生（比如可读就绪事件）后，就需要应用进程主动调用 read 方法来完成数据的读取，也就是要应用进程主动将 socket 接收缓存中的数据拷贝到应用进程内存中，这个过程是同步的，读取完数据后应用进程才能处理数据。")],1),_._v(" "),v("li",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("Proactor 是异步网络模式，感知的是已完成的读写事件")])]),_._v("。在异步请求发起时，需要传入应用内存数据缓冲区地址（用于存放读写完成的结果）等信息，这样操作系统就可以自动地把数据读写工作完成，并自动地将最终处理好的数据放入应用进程内存中，而不需要像 Reactor 一样由引用进程主动发起 read/write 请求来读写数据，Proactor 模式中操作系统自动完成数据读写工作后，就会直接通知应用程序直接处理数据。")],1)]),_._v(" "),v("p",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("Reactor就是 来了事件操作系统通知应用进程，让应用进程来处理")])])],1),_._v(" "),v("p",[v("font",{attrs:{color:"blue"}},[v("strong",[_._v("Proactor就是 来了事件操作系统直接处理，处理完了再通知应用进程。")])])],1),_._v(" "),v("blockquote",[v("p",[_._v("这里的「事件」就是有新连接、有数据可读、有数据可写的这些 I/O 事件这里的「处理」包含从驱动读取到内核以及从内核读取到用户空间。")])]),_._v(" "),v("p",[_._v("一个很贴切地例子 "),v("font",{attrs:{color:"blue"}},[_._v(" 快递员送货到楼下通知你下来取快递和直接送货上门的区别")])],1),_._v(" "),v("blockquote",[v("p",[_._v("Reactor 就是快递员送快递到楼下，通知你来取；Proactor 就是快递员直接将快递送到门口。")])]),_._v(" "),v("p",[_._v("总结：")]),_._v(" "),v("p",[_._v("无论是 Reactor，还是 Proactor，都是一种基于「事件分发」的网络编程模式，区别在于 "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("Reactor 模式是基于「待完成」的 I/O 事件，而 Proactor 模式则是基于「已完成」的 I/O 事件")]),_._v("。")])],1),_._v(" "),v("p",[_._v("Proactor流程图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/Proactor.png",alt:"Proactor"}})]),_._v(" "),v("p",[_._v("Proactor流程解析：")]),_._v(" "),v("ul",[v("li",[_._v("Proactor Initiator 负责创建 Proactor 和 Handler 对象，并将 Proactor 和 Handler 通过 Asynchronous Operation Processor 注册到内核；")]),_._v(" "),v("li",[_._v("Asynchronous Operation Processor 负责处理注册请求，并处理 I/O 操作；")]),_._v(" "),v("li",[_._v("Asynchronous Operation Processor 处理完 I/O 请求之后就通知 Proactor；")]),_._v(" "),v("li",[_._v("Proactor 根据不同的事件类型回调不同的Handler 进行业务处理；")]),_._v(" "),v("li",[_._v("Handler 完成业务处理")])]),_._v(" "),v("p",[_._v("可惜的是，在 Linux 下的异步 I/O 是不完善的， "),v("code",[_._v("aio")]),_._v(" 系列函数是由 POSIX 定义的异步操作接口，不是真正的操作系统级别支持的，而是在用户空间模拟出来的异步，并且仅仅支持基于本地文件的 aio 异步操作，网络编程中的 socket 是不支持的，这也使得基于 Linux 的高性能网络程序都是使用 Reactor 方案。")]),_._v(" "),v("p",[_._v("而 Windows 里实现了一套完整的支持 socket 的异步编程接口，这套接口就是 "),v("code",[_._v("IOCP")]),_._v("，是由操作系统级别实现的异步 I/O，真正意义上异步 I/O，因此在 Windows 里实现高性能网络程序可以使用效率更高的 Proactor 方案。")]),_._v(" "),v("blockquote",[v("p",[_._v("Linux 的aio是用户空间模拟出来的，不是由操作系统实现的；而Windows的异步操作 "),v("code",[_._v("IOCP")]),_._v(" 是操作系统级别实现的异步I/O，是真正意义上的异步 I/O.")])]),_._v(" "),v("h3",{attrs:{id:"一致性哈希"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一致性哈希"}},[_._v("#")]),_._v(" 一致性哈希")]),_._v(" "),v("p",[v("strong",[_._v("问题：什么是一致性哈希，使用场景，解决了什么问题？")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.png",alt:"一致性哈希"}})]),_._v(" "),v("p",[v("strong",[_._v("如何分配请求？")])]),_._v(" "),v("p",[_._v("多数网站背后不止一台服务器，因为单机的并发量和数据量都是有限的，所以都会用多台服务器构成集群来对外提供服务。")]),_._v(" "),v("p",[_._v("这就会引发新的问题：那么多节点该如何分配来自客户端的请求呢？（负载均衡问题）")]),_._v(" "),v("p",[v("strong",[_._v("最简单的方式，引入一个中间的负载均衡层")]),_._v("，让它将外界的请求「轮流」的转发给内部的集群。比如集群有 3 个节点，外界请求有 3 个，那么每个节点都会处理 1 个请求，达到了分配请求的目的。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%B1%82%E8%BD%AE%E6%B5%81%E8%BD%AC%E5%8F%91.png",alt:"负载均衡层轮流转发"}})]),_._v(" "),v("p",[_._v("考虑到每个节点的硬件配置有所区别，我们可以引入权重值，将硬件配置更好的节点的权重值设高，然后根据各个节点的权重值，按照一定比重分配在不同的节点上，让硬件配置更好的节点承担更多的请求，这种算法叫做"),v("strong",[_._v("加权轮询")]),_._v("。")]),_._v(" "),v("p",[_._v("加权轮询算法使用场景是建立在"),v("strong",[_._v("每个节点存储的数据都是相同")]),_._v("的前提。所以，每次读数据的请求，访问任意一个节点都能得到结果。")]),_._v(" "),v("p",[_._v("但是，加权轮询算法是无法应对「分布式系统（"),v("strong",[_._v("数据分片的系统")]),_._v("）」的，因为"),v("strong",[_._v("分布式系统中，每个节点存储的数据是不同的")]),_._v("。")]),_._v(" "),v("p",[_._v("当我们想提高系统的容量，就会将数据水平切分到不同的节点来存储，也就是将数据分布到了不同的节点。比如"),v("strong",[_._v("一个分布式 KV（key-valu） 缓存系统，某个 key 应该到哪个或者哪些节点上获得，应该是确定的")]),_._v("，不是说任意访问一个节点都可以得到缓存结果的。")]),_._v(" "),v("p",[_._v("因此，我们要想一个能应对分布式系统的负载均衡算法。")]),_._v(" "),v("p",[v("strong",[_._v("负载均衡算法使用哈希算法有啥问题？")])]),_._v(" "),v("p",[_._v("有的同学可能很快就想到了："),v("strong",[_._v("哈希算法")]),_._v("。因为对同一个关键字进行哈希计算，每次计算都是相同的值，这样就可以将某个 key 确定到一个节点了，可以满足分布式系统的负载均衡需求。")]),_._v(" "),v("p",[v("strong",[_._v("哈希算法最简单的做法就是进行取模运算")]),_._v("，比如分布式系统中有 3 个节点，基于 "),v("code",[_._v("hash(key) % 3")]),_._v(" 公式对数据进行了映射。")]),_._v(" "),v("p",[_._v("如果客户端要获取指定 key 的数据，通过下面的公式可以定位节点：")]),_._v(" "),v("div",{staticClass:"language-cpp extra-class"},[v("pre",{pre:!0,attrs:{class:"language-cpp"}},[v("code",[v("span",{pre:!0,attrs:{class:"token function"}},[_._v("hash")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v("(")]),_._v("key"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(")")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[_._v("%")]),_._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[_._v("3")]),_._v("\n")])])]),v("p",[_._v("但是有一个很致命的问题，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("如果节点数量发生了变化，也就是在对系统做扩容或者缩容时，必须迁移改变了映射关系的数据")])]),_._v("，否则会出现查询不到数据的问题。")],1),_._v(" "),v("p",[_._v("要解决这个问题，就需要进行 "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("数据迁移")])]),_._v("，节点数量改变，哈希函数改变，就需要重新对数据和节点做映射。")],1),_._v(" "),v("p",[_._v("假设总数据条数为 M，哈希算法在面对节点数量变化时，"),v("strong",[_._v("最坏情况下所有数据都需要迁移，所以它的数据迁移规模是 O(M)")]),_._v("，这样数据的"),v("strong",[_._v("迁移成本太高了")]),_._v("。")]),_._v(" "),v("p",[_._v("所以，我们应该要重新想一个新的算法，来避免分布式系统在扩容或者缩容时，发生过多的数据迁移。")]),_._v(" "),v("p",[v("strong",[_._v("使用一致性哈希有啥问题？")])]),_._v(" "),v("p",[_._v("一致性哈希就可以解决分布式系统在扩容或缩容时，发生过多数据迁移的问题。")]),_._v(" "),v("p",[_._v("一致性哈希也用到了取模运算，但与哈希算法不同的是，哈希算法是对节点的数量进行取模运算，而一致性哈希算法是对 2 ^ 32 进行取模运算，是一个固定值。")]),_._v(" "),v("p",[_._v("我们可以把一致哈希算法是对 2^32 进行取模运算的结果值组织成一个圆环，就像钟表一样，钟表的圆可以理解成由 60 个点组成的圆，而此处我们把这个圆想象成由 2^32 个点组成的圆，这个圆环被称为"),v("strong",[_._v("哈希环")]),_._v("，如下图：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%93%88%E5%B8%8C%E7%8E%AF.png",alt:"哈希环"}})]),_._v(" "),v("p",[_._v("一致性哈希要进行两步哈希：")]),_._v(" "),v("ul",[v("li",[_._v("第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；")]),_._v(" "),v("li",[_._v("第二步：当对数据进行存储或访问时，对数据进行哈希映射；")])]),_._v(" "),v("p",[_._v("所以，"),v("strong",[_._v("一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上")]),_._v("。")]),_._v(" "),v("p",[_._v("问题来了，对「数据」进行哈希映射得到一个结果要怎么找到存储该数据的节点呢？")]),_._v(" "),v("p",[_._v("答案是，映射的结果值往"),v("strong",[_._v("顺时针的方向的找到第一个节点")]),_._v("，就是存储该数据的节点。")]),_._v(" "),v("p",[v("strong",[_._v("下面是例子")])]),_._v(" "),v("p",[_._v("举个例子，有 3 个节点经过哈希计算，映射到了如下图的位置：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%93%88%E5%B8%8C%E8%8A%82%E7%82%B9.png",alt:"哈希节点"}})]),_._v(" "),v("p",[_._v("接着，对要查询的 key-01 进行哈希计算，确定此 key-01 映射在哈希环的位置，然后从这个位置往顺时针的方向找到第一个节点，就是存储该 key-01 数据的节点。")]),_._v(" "),v("p",[_._v("比如，下图中的 key-01 映射的位置，往顺时针的方向找到第一个节点就是节点 A。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%93%88%E5%B8%8CA.png",alt:"哈希A"}})]),_._v(" "),v("p",[_._v("所以，当需要对指定 key 的值进行读写的时候，要通过下面 2 步进行寻址：")]),_._v(" "),v("ul",[v("li",[_._v("首先，对 key 进行哈希计算，确定此 key 在环上的位置；")]),_._v(" "),v("li",[_._v("然后，从这个位置沿着顺时针方向走，遇到的第一节点就是存储 key 的节点。")])]),_._v(" "),v("p",[_._v("知道了一致哈希寻址的方式，我们来看看，"),v("strong",[_._v("如果增加一个节点或者减少一个节点会发生大量的数据迁移吗？")])]),_._v(" "),v("p",[_._v("假设节点数量从 3 增加到了 4，新的节点 D 经过哈希计算后映射到了下图中的位置：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB.png",alt:"数据迁移"}})]),_._v(" "),v("p",[_._v("你可以看到，key-01、key-03 都不受影响，只有 key-02 需要被迁移节点 D。")]),_._v(" "),v("p",[_._v("假设节点数量从 3 减少到了 2，比如将节点 A 移除：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BBB.png",alt:"数据迁移B"}})]),_._v(" "),v("p",[_._v("你可以看到，key-02 和 key-03 不会受到影响，只有 key-01 需要被迁移节点 B。")]),_._v(" "),v("p",[_._v("因此，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("在一致哈希算法中，如果增加或者移除一个节点，仅影响该节点在哈希环上顺时针相邻的后继节点，其它数据也不会受到影响")]),_._v("。")])],1),_._v(" "),v("p",[_._v("上面这些图中 3 个节点映射在哈希环还是比较分散的，所以看起来请求都会「均衡」到每个节点。")]),_._v(" "),v("p",[v("strong",[_._v("一致性哈希算法的问题：")])]),_._v(" "),v("p",[_._v("但是 "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("一致性哈希算法并不保证节点能够在哈希环上分布均匀")])]),_._v("，这样就会带来一个问题，会"),v("strong",[_._v("有大量的请求集中在一个节点上")]),_._v("。")],1),_._v(" "),v("p",[_._v("比如，下图中 3 个节点的映射位置都在哈希环的右半边：")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E4%B8%8A.png",alt:"大量数据分配到一个节点上"}})]),_._v(" "),v("p",[_._v("这时候有一半以上的数据的寻址都会找节点 A，也就是访问请求主要集中的节点 A 上，这肯定不行的呀，说好的负载均衡呢，这种情况一点都不均衡。")]),_._v(" "),v("p",[_._v("另外，在这种节点分布不均匀的情况下，进行容灾与扩容时，哈希环上的相邻节点容易受到过大影响，容易发生雪崩式的连锁反应。")]),_._v(" "),v("p",[_._v("比如，上图中如果节点 A 被移除了，当节点 A 宕机后，根据一致性哈希算法的规则，其上数据应该全部迁移到相邻的节点 B 上，这样，节点 B 的数据量、访问量都会迅速增加很多倍，一旦新增的压力超过了节点 B 的处理能力上限，就会导致节点 B 崩溃，进而形成雪崩式的连锁反应。")]),_._v(" "),v("p",[_._v("所以，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("一致性哈希算法虽然减少了数据迁移量，但是存在节点分布不均匀的问题")]),_._v("。")])],1),_._v(" "),v("h3",{attrs:{id:""}},[v("a",{staticClass:"header-anchor",attrs:{href:"#"}},[_._v("#")])]),_._v(" "),v("p",[v("strong",[_._v("通过虚拟节点提高均衡度")])]),_._v(" "),v("p",[_._v("要想解决节点能在哈希环上分配不均匀的问题，就是要有大量的节点，节点数越多，哈希环上的节点分布的就越均匀。")]),_._v(" "),v("p",[_._v("但问题是，实际中我们没有那么多节点。所以这个时候我们就加入"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("虚拟节点")])]),_._v("，也就是对一个真实节点做多个副本。")],1),_._v(" "),v("p",[_._v("具体做法是，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。")])])],1),_._v(" "),v("p",[_._v("比如对每个节点分别设置 3 个虚拟节点：")]),_._v(" "),v("ul",[v("li",[_._v("对节点 A 加上编号来作为虚拟节点：A-01、A-02、A-03")]),_._v(" "),v("li",[_._v("对节点 B 加上编号来作为虚拟节点：B-01、B-02、B-03")]),_._v(" "),v("li",[_._v("对节点 C 加上编号来作为虚拟节点：C-01、C-02、C-03")])]),_._v(" "),v("p",[_._v("引入虚拟节点后，原本哈希环上只有 3 个节点的情况，就会变成有 9 个虚拟节点映射到哈希环上，哈希环上的节点数量多了 3 倍。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png",alt:"虚拟节点"}})]),_._v(" "),v("p",[_._v("可以看到， "),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("节点数量变多了之后，节点在哈希环上的分布就相对均匀了")])]),_._v("。这时候，如果有访问请求寻址到「A-01」这个虚拟节点，接着再通过「A-01」虚拟节点找到真实节点 A，这样请求就能访问到真实节点 A 了。")],1),_._v(" "),v("blockquote",[v("p",[_._v("上面为了便于理解，每个真实节点仅包含 3 个虚拟节点，这样能起到的均衡效果其实很有限。而在实际的工程中，虚拟节点的数量会大很多，比如 Nginx 的一致性哈希算法，每个权重为 1 的真实节点就含有160 个虚拟节点。")])]),_._v(" "),v("p",[_._v("另外，虚拟节点除了会提高节点的均衡度，还会提高系统的稳定性。"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("当节点变化时，会有不同的节点共同分担系统的变化，因此稳定性更高")]),_._v("。")])],1),_._v(" "),v("blockquote",[v("p",[_._v("比如，当某个节点被移除时，对应该节点的多个虚拟节点均会移除，而这些虚拟节点按顺时针方向的下一个虚拟节点，可能会对应不同的真实节点，即这些不同的真实节点共同分担了节点变化导致的压力。")])]),_._v(" "),v("p",[_._v("而且，有了虚拟节点后，还可以为硬件配置更好的节点增加权重，比如对权重更高的节点增加更多的虚拟机节点即可。")]),_._v(" "),v("p",[_._v("因此，"),v("font",{attrs:{color:"blue"}},[v("strong",[_._v("带虚拟节点的一致性哈希方法不仅适合硬件配置不同的节点的场景，而且适合节点规模会发生变化的场景")]),_._v("。")])],1)])}),[],!1,null,null,null);v.default=a.exports}}]);