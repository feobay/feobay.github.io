(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{291:function(t,s,a){"use strict";a.r(s);var n=a(14),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"effectivec"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#effectivec"}},[t._v("#")]),t._v(" EffectiveC++")]),t._v(" "),s("h2",{attrs:{id:"条款01-视c-为一个语言联邦"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款01-视c-为一个语言联邦"}},[t._v("#")]),t._v(" 条款01：视C++为一个语言联邦")]),t._v(" "),s("p",[t._v("C++包含四大部分")]),t._v(" "),s("p",[s("strong",[t._v("C")]),t._v("， "),s("strong",[t._v("Objected-Oriented C++")]),t._v("， "),s("strong",[t._v("Template C++")]),t._v("， "),s("strong",[t._v("STL")])]),t._v(" "),s("h2",{attrs:{id:"条款02-尽量以const-enum-inline替换-define"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款02-尽量以const-enum-inline替换-define"}},[t._v("#")]),t._v(" 条款02：尽量以const，enum，inline替换#define")]),t._v(" "),s("p",[t._v("①编译器看不见define的常量名称，如 "),s("code",[t._v("#define pi 3.14")]),t._v(" 在预处理后展开为3.14，编译器无法识别，这样debug时编译器报错无法追溯到具体的变量")]),t._v(" "),s("blockquote",[s("p",[t._v("C++11中用 "),s("code",[t._v("nullptr")]),t._v(" (nullptr_t 类型的右值常量，专用于初始化空指针)替代 "),s("code",[t._v("NULL")]),t._v("（宏定义）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("nullptr可以被隐式转换为任意类型的指针，但不能被隐式转换为整型；这与 NULL 不同")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isnull")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"void*c"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isnull")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"int n"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isnull")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 结果为int n")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isnull")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 结果为void*c")]),t._v("\n")])])]),s("p",[t._v("总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。")])])])]),t._v(" "),s("p",[t._v("②const，enum可以被封装，且enum与define类似不能被取地址")]),t._v(" "),s("p",[t._v("③宏定义的函数会出一些问题，例如一下：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<iostream>")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("using")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("namespace")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token macro-name function"}},[t._v("CALL_WITH_MAX")]),s("span",{pre:!0,attrs:{class:"token expression"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")])])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 宏定义单纯是用匹配的位置直接进行字符串替换")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 也就是说 CALL_WITH_(++a, b) 等价于")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// f((++a) > (b) ? (++a) : (b)) , 结果是true的话a将被累加两次")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 由于C/C++程序编译顺序为 预处理 -> 编译 -> 汇编 -> 链接")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 所以在++a(或其它表达式被计算之前)，宏定义就已经展开")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//为了避免这种错误，使用template inline可以获得同等高的效率")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("template")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typename")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("inline")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("callWithMax")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" T"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//使用常量引用防止新的内存消耗且禁止在函数内部修改值")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CALL_WITH_MAX")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a累加2次，第一次累加后a为6 > b(0), 所以返回?后的a,此时再次累加一次得到a=7")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("CALL_WITH_MAX")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a累加1次，第一次累加后a=8，a < b(10), 所以?后返回b不再为a进行累加，")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最后a为8")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("callWithMax")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("使用 inline替换#define可以很好解决")]),t._v(" "),s("p",[t._v("小结：")]),t._v(" "),s("ul",[s("li",[t._v("对于单纯常量，最好以const对象或enum 替换#define")]),t._v(" "),s("li",[t._v("对于形似函数的宏（macros），最好改用inline函数替换#define")])]),t._v(" "),s("h2",{attrs:{id:"条款03-尽可能使用const"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款03-尽可能使用const"}},[t._v("#")]),t._v(" 条款03：尽可能使用const")]),t._v(" "),s("p",[t._v("const 在 "),s("code",[t._v("*")]),t._v(" 左边表示指向的对象是常量; const在"),s("code",[t._v("*")]),t._v("右边表示指针本身是常量，指向地址不变。")]),t._v(" "),s("blockquote",[s("p",[t._v("注意，"),s("code",[t._v("*")]),t._v(" 肯定在类型后面才是正确的语法")])]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Widget"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" pw"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nWidget "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" pw"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 两种都是对象是常量")]),t._v("\n")])])]),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//指向的对象是常量")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" p3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//指针是常量")]),t._v("\n")])])]),s("p",[t._v("对于迭代器，"),s("code",[t._v("const")]),t._v(" 关键字直接作用于 "),s("code",[t._v("iterator")]),t._v(" 本身，会得到一个"),s("strong",[t._v("指向无法改变")]),t._v("的指针；（iterator作用类似于T*, const iterator 类似于 T * const)")]),t._v(" "),s("blockquote",[s("p",[t._v("const (type)::iterator it; ++it; // 错误，it指向无法改变")])]),t._v(" "),s("p",[t._v("想要"),s("strong",[t._v("内容无法改变的迭代器")]),t._v("，则可以 直接用 "),s("code",[t._v("::const_iterator")]),t._v(" (const_iterator 作用类似于 const T *)")]),t._v(" "),s("blockquote",[s("p",[t._v("(type)::const_itarotor cIt; ++cIt; // 正确，指向可以改变 *cIt = 2; // 错误，cIt指向对象的内容无法被更改")])]),t._v(" "),s("p",[s("strong",[s("code",[t._v("const")]),t._v(" 可以用来声明 函数返回值、各参数、函数自身（如果是成员函数，类中的长函数，在函数名后声明const）")])]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("为什么要将返回值声明为const？")])])],1),t._v(" "),s("p",[t._v("是为了防止表达式的结果被更改，比如进行 operator* 运算符重载时返回常量，让其成为右值。 避免以下错误：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将 operator* 的返回值定义为const，这种无意识的错误就可以避免")]),t._v("\n")])])]),s("p",[t._v("对于 "),s("code",[t._v("operator[]")]),t._v(" 如果返回值类型为 char 的 引用，那么返回值可以修改，但如果单纯返回的是一个内置类型如char，由于其为字面值（右值）而非变量，所以无法修改。")]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("const 成员函数的作用？")])])],1),t._v(" "),s("ul",[s("li",[t._v("使得class接口易于被理解，易于分辨哪些函数可以改动对象内容而哪些不可以")]),t._v(" "),s("li",[t._v("用于实现 "),s("em",[s("strong",[t._v("pass by reference-to-const")])]),t._v(" ，"),s("code",[t._v("void func(const T& a) const {}")])])]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("成员函数可以通过其常量性不同来重载。")])])],1),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("const成员函数有两种哲学：")])])],1),t._v(" "),s("ul",[s("li",[s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("bitwise constness")])]),t._v("：不改变对象中的任何一个bit")],1),t._v(" "),s("blockquote",[s("p",[t._v("有个问题，根据该原则，对象的所属成员指针指向不能改变，但指针指向的对象却不属于初始对象，所以其内容可以改变。")]),t._v(" "),s("p",[t._v("PS：mutable 关键字有助于释放 non-static 成员变量的 bitwise-constness")])])]),t._v(" "),s("li",[s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("logical constness")])]),t._v("：const成员函数可以修改它所处理的对象内的某些bits")],1),t._v(" "),s("blockquote",[s("p",[t._v("可以根据所需要达成的目的，进行逻辑上的约束")])])])]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("运算符重载可以做很多安全性检测。")])])],1),t._v(" "),s("blockquote",[s("p",[t._v("operator[] 不单是返回一个 reference 指向某字符，也执行 边界检验（bounds checking）、志记访问信息（logged access info）、数据完整性检验。")])]),t._v(" "),s("p",[t._v("将这些检验同时塞进const 和 non-const operator[] 中就会引发很多问题。为了解决这个问题，我们就需要：")]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("消除重复代码，在 non-const operator[] 中调用 const operator[].")])])],1),t._v(" "),s("p",[t._v("具体做法如下：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TextBlock")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("size_t position"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" text"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("position"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("size_t position"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token generic-function"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("const_cast")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 将op[]的返回值的const移除")]),t._v("\n        \t"),s("span",{pre:!0,attrs:{class:"token generic-function"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("static_cast")]),s("span",{pre:!0,attrs:{class:"token generic class-name"}},[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" TextBlock"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 为*this加上cosnt")]),t._v("\n            \t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("position"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\t\t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 调用const char& op[]")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("可以看到进行了两次转型：")]),t._v(" "),s("ul",[s("li",[t._v("第一次为 *this 添加 const（这使得接下来调用 operator[] 时得以调用 const 版本）")]),t._v(" "),s("li",[t._v("第二次 则是从 const operator[] 的返回值中移除 const")])])]),t._v(" "),s("p",[t._v("如果在const函数内调用non-const版本，那么可能出现风险：你曾承诺不改动的那个对象被改动了。")]),t._v(" "),s("p",[s("strong",[t._v("小结：")])]),t._v(" "),s("ul",[s("li",[t._v("将某些东西声明为const有助于编译器侦测出错误用法")]),t._v(" "),s("li",[t._v("编译器强制实施 bitwise constness，但我们编写程序时应当使用“概念上的常量性”（conceptual constness)")]),t._v(" "),s("li",[t._v("当 const 和 non-const 版本成员函数有着实质等价的实现时，"),s("strong",[t._v("在 non-const 版本中调用 const 版本可避免代码重复")])])]),t._v(" "),s("h2",{attrs:{id:"条款04-确定对象被使用前已先被初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款04-确定对象被使用前已先被初始化"}},[t._v("#")]),t._v(" 条款04：确定对象被使用前已先被初始化")]),t._v(" "),s("p",[s("strong",[t._v("做法：")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("手动初始化")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t\t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对 int 进行手工初始化")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" text "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"A C-style string"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对指针进行手工初始化")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cin "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \t\t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 通过 input stream 的方式完成初始化")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("内置类型以外的通过 "),s("strong",[t._v("构造函数（constructors）初始化")])]),t._v(" "),s("blockquote",[s("p",[t._v("规则就是：确保每一个构造函数都将对象的每一个成员初始化")]),t._v(" "),s("p",[t._v("要注意的就是不要混淆 "),s("strong",[t._v("赋值")]),t._v("（在函数体内使用 ‘=’ 叫做赋值） 和 "),s("strong",[t._v("初始化")]),t._v("（通过参数列表初始化）")]),t._v(" "),s("p",[t._v("C++定义：对象成员变量的初始化发生于进入构造函数体内之前")]),t._v(" "),s("p",[t._v("所以也可以在对象成员生命处直接初始化，然后默认构造函数直接声明外 name() = default;（注意：static成员应该在类内声明类外初始化）")])])])]),t._v(" "),s("p",[t._v("基于赋值的版本首先调用 "),s("em",[s("strong",[t._v("default")])]),t._v(" 构造函数为成员变量赋初值，然后为他们设置新值，这样 第一次赋初值就浪费了。所以通过成员初始值列表来初始化避免该问题。")]),t._v(" "),s("p",[t._v("也就是说：构造函数赋值 = 先 default构造 + 再 调用 copy assignment 操作符")]),t._v(" "),s("p",[t._v("如果只想要使用 "),s("em",[s("strong",[t._v("default")])]),t._v(" 构造一个成员变量，也可以通过无参的成员初值列表来实现：")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ABEntry")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ABEntry")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("theName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("theAddress")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n\t  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("thePhones")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" \t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 因为编译器会为用户自定义类型自动调用默认构造函数，所以前三个会调用它们的 default 构造函数")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("numTimesConsulted")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[s("font",{attrs:{color:"red"}},[s("strong",[t._v("记住要在初值列表中列出所有成员变量。")])])],1),t._v(" "),s("blockquote",[s("p",[t._v("如果遗漏了就会导致有些成员没有初值，进而引发不明确行为。")])]),t._v(" "),s("p",[s("strong",[t._v("额外注意：")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("对于有些内置类型也需要使用初值列表")]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("成员变量为 const 或 reference，就一定需要处初值列表，不能只用赋值")])])],1),t._v(" "),s("p",[t._v("所以最好的做法就是所有时候都"),s("strong",[t._v("只用 初始化列表")])])]),t._v(" "),s("li",[s("p",[t._v("合理使用赋值替换初始化")]),t._v(" "),s("blockquote",[s("p",[t._v("许多 classes 拥有多个构造函数，每个构造函数有自己的成员初值列表。如果 这种 classes 里边存在许多成员变量和/或 base classes，多份成员初值列表会导致许多重复初始化，这时候可以合理用一些赋值来替换初始化某些变量，同时赋值操作就一起封装在某个private成员函数中，提供给构造函数使用。")]),t._v(" "),s("p",[t._v("这种做法在 "),s("font",{attrs:{color:"blue"}},[s("strong",[t._v("从文件或数据库中读入数据来给成员变量赋初值时")])]),t._v(" 很有用")],1)])]),t._v(" "),s("li",[s("p",[t._v("初始化最好按照声明顺序初始化")])]),t._v(" "),s("li",[s("p",[t._v("还需要注意 "),s("code",[t._v("non-local static")]),t._v(" 对象 的初始化顺序")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("static 对象寿命从被构造出来直到程序结束为止")])]),t._v(" "),s("li",[s("p",[t._v("函数内的 static对象为 local static，它们是函数内的局部变量")])]),t._v(" "),s("li",[s("p",[t._v("其它static（global对象、namespace作用域内的对象、classes内的、file作用域内被声明的static）都是 non-local static")])]),t._v(" "),s("li",[s("p",[t._v("程序结束时，static对象会被自动销毁，它们的析构函数会在 main() 结束时被自动调用")])]),t._v(" "),s("li",[s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("问题：某编译单元内的某个non-local static 对象的初始化动作使用了另一个编译单元内的某个 non-local static 对象，它所使用的对象可能并未初始化，因为C++并未定义不同编译单元内static对象的初始化顺序。")])])],1),t._v(" "),s("blockquote",[s("p",[t._v("编译单元（translation unit）是指产出单一目标文件（single object file）的那些源码。基本上它是单一源码文件加上其所含入的头文件。")])]),t._v(" "),s("p",[t._v("消除该问题需要做的是：将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static）。这些函数返回一个 reference 指向它所含的对象。"),s("code",[t._v("T& getX() { static T x; return x;}")]),t._v(" 然后用户调用这些函数而不直接指涉这些对象。换句话说，non-static 对象被 local static 对象替换了。这是 ***Singleton***模式（单例模式）的经典实现。")]),t._v(" "),s("p",[t._v("这个手法的基础：C++保证，函数内的local static 对象会在 “该函数被调用期间” ”第一次遇上该对象的定义式“ 时被初始化。所以用 ”函数调用“（返回一个 reference to local static) 替换 ”直接访问non-local static 对象“，可以保证所获得的reference将指向一个被初始化的对象。并且 "),s("strong",[t._v("如果从未调用那个non-static 对象的"),s("code",[t._v("getX()")]),t._v("  函数，那么就一定不会引发构造和析构成本，这比真正的 non-local static 对象更有优势。")])]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 来自你写的服务端程序：")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("FileSystem")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 下面时来自客户端的程序")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 省去了 extern tfs")]),t._v("\nFileSystem"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 用这个函数来替换tfs对象")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" FileSystem fs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义并初始化一个local static对象（这里的fs已经在服务端程序初始化）")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" fs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回一个 reference 指向上述对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Directory")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Directory")]),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Directory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" params"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n    std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("size_t disks "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tfs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("numDisks")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用tfs() 来替换直接访问 tfs对象")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nDirectory"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("tempDir")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" Directory td"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义并初始化 local static 对象")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" td"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\t\t\t "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 返回一个reference指向上述对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这种简短的函数及其适合inline")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("同时上述做法会让其在多线程函数中出现隐患")]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("在程序的的单线程启动阶段手工调用所有 reference-returning 函数，可以消除与初始化次序有关的”竞速情况”")])])],1)])])])]),t._v(" "),s("p",[s("strong",[t._v("小结：")])]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("为内置型对象进行手工初始化，因为C++不保证初始化它们。")])]),t._v(" "),s("li",[s("strong",[t._v("构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。")])]),t._v(" "),s("li",[s("strong",[t._v("为免除”跨编译单元之初始化次序”问题，请以local static对象替换non-local static对象")]),t._v("。")])]),t._v(" "),s("h2",{attrs:{id:"条款05-了解c-默默编写并调用哪些函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款05-了解c-默默编写并调用哪些函数"}},[t._v("#")]),t._v(" 条款05：了解C++默默编写并调用哪些函数")]),t._v(" "),s("p",[t._v("如果你没有声明，C++类中默认有 "),s("strong",[t._v("默认构造函数、一个拷贝构造函数、一个拷贝赋值操作符（=）重载函数、一个析构函数")]),t._v("，它们都是 "),s("strong",[t._v("public 且 inline 的。")])]),t._v(" "),s("p",[t._v("并且从左到有，如果你自己手动声明了一个默认构造函数的化，那么左边的那些函数系统就不会再生成。")]),t._v(" "),s("p",[t._v("比如：你自己定义了一个拷贝构造，那么系统不再给你提供默认构造。")]),t._v(" "),s("p",[t._v("例子：")]),t._v(" "),s("blockquote",[s("p",[t._v("对于一个空类 empty")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("empty")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("其等价于")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("empty")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Empty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\t\t\t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// default构造函数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Empty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Empty"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" rhs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// copy构造函数")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Empty")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\t\t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 析构函数")]),t._v("\n    \t\t\t\t\t\t\t\t\t\t\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// virtual 函数后面再说")]),t._v("\n    Empty"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Empty"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" rhs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// copy assignment构造函数")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])]),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("编译器产出的析构函数时non-virtual的，virtual属性需要手动声明，除非它的base class的析构函数是个virtual的")])])],1),t._v(" "),s("p",[s("font",{attrs:{color:"blue"}},[s("strong",[t._v("如果你编写了一个有参构造函数，那么编译器不再提供默认构造函数；并且，对于默认拷贝构造函数而言，对应的参数一定需要对应才行")])])],1),t._v(" "),s("h2",{attrs:{id:"条款06-若不想使用编译器自动生成的函数-就该明确拒绝"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款06-若不想使用编译器自动生成的函数-就该明确拒绝"}},[t._v("#")]),t._v(" 条款06：若不想使用编译器自动生成的函数，就该明确拒绝")]),t._v(" "),s("p",[t._v("一般来说不想要某个函数自己不声明就够了，但是对于默认生成的则需要手动控制。")]),t._v(" "),s("p",[s("strong",[t._v("下面是方法：")])]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("将编译器默认生成的拷贝函数声明为private并且不定义")]),t._v("。但这个做法不完全安全，因为成员函数和友元friend函数都可以调用private，但不定义就可以做到防止被人调用（此时会返回链接错误）。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Uncopyable")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Uncopyable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Uncopyable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("friend")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Uncopyable")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" Uncopyable "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Newuc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token base-clause"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Uncopyable")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Uncopyable c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    Uncopyable "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("c2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Newuc nc1;")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Newuc nc2(nc1);")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("调用 "),s("code",[t._v("func()")]),t._v(" 发现报错 "),s("code",[t._v("collect2.exe: error: ld returned 1 exit status")])]),t._v(" "),s("p",[s("strong",[t._v("而有了一个这种不可被拷贝的类后，子类只需要私有继承这个不可被拷贝类即可使其自身也不可被拷贝")]),t._v("，因为父类的拷贝构造被定义为私有的，所以子类不能调用父类的拷贝构造函数，所以子类中的拷贝构造被删除。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://feobay.oss-cn-shanghai.aliyuncs.com/img/image-20230331201359958.png",alt:"image-20230331201359958"}})])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("使用C++11提供的delete关键词新用法")]),t._v("。")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyObj")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MyObj")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻止编译器合成构造函数，会导致类无法实例化")]),t._v("\n  MyObj"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MyObj")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" MyObj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻止编译器合成拷贝构造函数，会导致类无法拷贝构造，如std::cin, std::cout")]),t._v("\n  MyObj"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("operator")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" MyObj "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("delete")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 阻止合成赋值运算符，会导致类无法拷贝，如cin, cout, cerr")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])]),t._v(" "),s("p",[s("strong",[t._v("小结")]),t._v("：为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为 "),s("code",[t._v("private")]),t._v(" 并且不予实现。使用像Uncopyable这样的base class也是一种做法。")]),t._v(" "),s("h2",{attrs:{id:"条款07-为多态基类声明virtual析构函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#条款07-为多态基类声明virtual析构函数"}},[t._v("#")]),t._v(" 条款07：为多态基类声明virtual析构函数")]),t._v(" "),s("p",[t._v("virtual函数一般用于多态，使用父类指针指向子类对象时，通过父类指针调用函数，此时调用的是子类函数，这就是多态。")]),t._v(" "),s("p",[t._v("实现原理：使用virtual后会在子类对象中添加一个函数指针，函数指针指向一个虚函数表，虚函数表中存放了virtual函数的函数地址，如果子类重写了父类中的虚函数，那么就由子类函数的地址覆盖父类函数地址。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("当基类的指针指向子类的对象，而基类的析构函数不是虚析构，那么此时 delete父类指针时就不会执行子类析构，导致内存泄漏")])]),t._v(" "),s("li",[s("p",[t._v("如果要继承std::string，也不行，因为std::string有个非虚析构函数")])]),t._v(" "),s("li",[s("p",[t._v("有时候可以考虑声明一个纯析构函数")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("virtual")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ClassName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使该类成为抽象类，不能实例化")]),t._v("\n")])])])]),t._v(" "),s("li",[s("p",[t._v("析构函数的调用规则是，先子类后父类")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);